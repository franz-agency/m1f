======= html2md.py ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""
HTML to Markdown converter - wrapper script.
"""

import sys
import os
from pathlib import Path

if __name__ == "__main__":
    # Add the parent directory to sys.path for proper imports
    script_dir = Path(__file__).parent
    parent_dir = script_dir.parent

    # Try different import strategies based on execution context
    try:
        # First try as if we're in the m1f package
        from tools.html2md_tool.cli import main
    except ImportError:
        try:
            # Try adding parent to path and importing
            if str(parent_dir) not in sys.path:
                sys.path.insert(0, str(parent_dir))
            from tools.html2md_tool.cli import main
        except ImportError:
            # Fallback for direct script execution
            if str(script_dir) not in sys.path:
                sys.path.insert(0, str(script_dir))
            from html2md_tool.cli import main

    main()

======= path_utils.py ======
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

from pathlib import Path, PureWindowsPath


def convert_to_posix_path(path_val: str) -> str:
    """Convert a path string to POSIX style."""
    return PureWindowsPath(path_val).as_posix()


def normalize_path(path: Path | str) -> str:
    """Normalize a Path or path-like object to POSIX style."""
    return PureWindowsPath(str(path)).as_posix()

======= html2md_tool/__init__.py ======
"""
HTML to Markdown Converter - Modern Web Content Extraction Tool

A powerful, modular tool for converting HTML content to Markdown format,
optimized for processing entire websites and integration with m1f.
"""

# Get version from package metadata
try:
    from importlib.metadata import version

    __version__ = version("m1f")
    __version_info__ = tuple(int(x) for x in __version__.split(".")[:3])
except Exception:
    # During development, version might not be available
    __version__ = "dev"
    __version_info__ = (0, 0, 0)

__author__ = "Franz und Franz (https://franz.agency)"

from html2md_tool.api import Html2mdConverter
from html2md_tool.config import Config, ConversionOptions
from html2md_tool.core import HTMLParser, MarkdownConverter
from html2md_tool.utils import (
    convert_html,
    adjust_internal_links,
    extract_title_from_html,
)

# Alias for backward compatibility
HTML2MDConverter = Html2mdConverter

__all__ = [
    "Html2mdConverter",
    "HTML2MDConverter",  # Alias
    "Config",
    "ConversionOptions",
    "HTMLParser",
    "MarkdownConverter",
    "convert_html",
    "adjust_internal_links",
    "extract_title_from_html",
]

======= html2md_tool/__main__.py ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""Module execution entry point for mf1-html2md."""

from html2md_tool.cli import main

if __name__ == "__main__":
    main()

======= html2md_tool/analyze_html.py ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Analyze HTML files to suggest preprocessing configuration."""

import argparse
from pathlib import Path
from bs4 import BeautifulSoup, Comment
from collections import Counter, defaultdict
from typing import List, Dict, Set, Tuple
import json
import sys

from m1f.file_operations import safe_exists, safe_open
from shared.colors import success, error, warning, info


class HTMLAnalyzer:
    """Analyze HTML files to identify patterns for preprocessing."""

    def __init__(self):
        self.reset_stats()

    def reset_stats(self):
        """Reset analysis statistics."""
        self.element_counts = Counter()
        self.class_counts = Counter()
        self.id_counts = Counter()
        self.comment_samples = []
        self.url_patterns = defaultdict(set)
        self.meta_patterns = defaultdict(list)
        self.empty_elements = Counter()
        self.script_styles = {"script": [], "style": []}

    def analyze_file(self, file_path: Path) -> Dict:
        """Analyze a single HTML file."""
        try:
            with safe_open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                html = f.read()
        except Exception as e:
            return {"error": str(e)}

        soup = BeautifulSoup(html, "html.parser")

        # Count all elements
        for tag in soup.find_all():
            self.element_counts[tag.name] += 1

            # Count classes
            if classes := tag.get("class"):
                for cls in classes:
                    self.class_counts[cls] += 1

            # Count IDs
            if tag_id := tag.get("id"):
                self.id_counts[tag_id] += 1

            # Check for empty elements
            if (
                tag.name not in ["img", "br", "hr", "input", "meta", "link"]
                and not tag.get_text(strip=True)
                and not tag.find_all(["img", "table", "ul", "ol"])
            ):
                self.empty_elements[tag.name] += 1

        # Analyze comments
        for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):
            comment_text = str(comment).strip()
            if len(comment_text) < 200:  # Only short comments
                self.comment_samples.append(comment_text)

        # Analyze URLs
        for tag in soup.find_all(["a", "link", "img", "script"]):
            for attr in ["href", "src"]:
                if url := tag.get(attr):
                    # Identify patterns
                    if url.startswith("file://"):
                        self.url_patterns["file_urls"].add(url[:50] + "...")
                    elif url.startswith("http://") or url.startswith("https://"):
                        self.url_patterns["absolute_urls"].add(url[:50] + "...")
                    elif url.startswith("/"):
                        self.url_patterns["root_relative"].add(url[:50] + "...")

        # Analyze meta information sections
        # Look for common patterns like "Written by", "Last updated", etc.
        for text in soup.find_all(string=True):
            text_str = text.strip()
            if any(
                pattern in text_str
                for pattern in [
                    "Written by:",
                    "Last updated:",
                    "Created:",
                    "Modified:",
                    "Author:",
                    "Maintainer:",
                ]
            ):
                parent = text.parent
                if parent:
                    self.meta_patterns["metadata_text"].append(
                        {
                            "text": text_str[:100],
                            "parent_tag": parent.name,
                            "parent_class": parent.get("class", []),
                        }
                    )

        # Sample script/style content
        for tag_type in ["script", "style"]:
            for tag in soup.find_all(tag_type)[:3]:  # First 3 of each
                content = tag.get_text()[:200]
                if content:
                    self.script_styles[tag_type].append(content + "...")

        return {"file": str(file_path), "success": True}

    def suggest_config(self) -> Dict:
        """Suggest preprocessing configuration based on analysis."""
        suggestions = {
            "remove_elements": ["script", "style"],  # Always remove these
            "remove_selectors": [],
            "remove_ids": [],
            "remove_classes": [],
            "remove_comments_containing": [],
            "fix_url_patterns": {},
            "remove_empty_elements": False,
        }

        # Suggest removing rare IDs (likely unique to layout)
        total_files = sum(1 for count in self.id_counts.values())
        for id_name, count in self.id_counts.items():
            if count == 1 and any(
                pattern in id_name.lower()
                for pattern in [
                    "header",
                    "footer",
                    "nav",
                    "sidebar",
                    "menu",
                    "path",
                    "breadcrumb",
                ]
            ):
                suggestions["remove_ids"].append(id_name)

        # Suggest removing common layout classes
        layout_keywords = [
            "header",
            "footer",
            "nav",
            "menu",
            "sidebar",
            "toolbar",
            "breadcrumb",
            "metadata",
            "pageinfo",
        ]
        for class_name, count in self.class_counts.items():
            if any(keyword in class_name.lower() for keyword in layout_keywords):
                suggestions["remove_classes"].append(class_name)

        # Suggest comment patterns to remove
        comment_keywords = ["Generated", "HTTrack", "Mirrored", "Added by"]
        seen_patterns = set()
        for comment in self.comment_samples:
            for keyword in comment_keywords:
                if keyword in comment and keyword not in seen_patterns:
                    suggestions["remove_comments_containing"].append(keyword)
                    seen_patterns.add(keyword)

        # Suggest URL fixes
        if self.url_patterns["file_urls"]:
            suggestions["fix_url_patterns"]["file://"] = "./"

        # Suggest removing empty elements if many found
        total_empty = sum(self.empty_elements.values())
        if total_empty > 10:
            suggestions["remove_empty_elements"] = True

        # Remove empty lists from suggestions
        suggestions = {k: v for k, v in suggestions.items() if v or isinstance(v, bool)}

        return suggestions

    def get_report(self) -> Dict:
        """Get detailed analysis report."""
        return {
            "statistics": {
                "total_elements": sum(self.element_counts.values()),
                "unique_elements": len(self.element_counts),
                "unique_classes": len(self.class_counts),
                "unique_ids": len(self.id_counts),
                "empty_elements": sum(self.empty_elements.values()),
                "comments_found": len(self.comment_samples),
            },
            "top_elements": self.element_counts.most_common(10),
            "top_classes": self.class_counts.most_common(10),
            "top_ids": self.id_counts.most_common(10),
            "url_patterns": {k: list(v)[:5] for k, v in self.url_patterns.items()},
            "comment_samples": self.comment_samples[:5],
            "metadata_patterns": self.meta_patterns,
        }


def main():
    parser = argparse.ArgumentParser(
        description="Analyze HTML files for preprocessing configuration"
    )
    parser.add_argument("files", nargs="+", help="HTML files to analyze")
    parser.add_argument("--output", "-o", help="Output configuration file (JSON)")
    parser.add_argument(
        "--report", "-r", action="store_true", help="Show detailed report"
    )

    args = parser.parse_args()

    analyzer = HTMLAnalyzer()

    # Analyze all files
    info(f"Analyzing {len(args.files)} files...")
    for file_path in args.files:
        path = Path(file_path)
        if safe_exists(path) and path.suffix.lower() in [".html", ".htm"]:
            result = analyzer.analyze_file(path)
            if "error" in result:
                error(f"Error analyzing {path}: {result['error']}")

    # Get suggestions
    config = analyzer.suggest_config()

    # Show report if requested
    if args.report:
        report = analyzer.get_report()
        info("\n=== Analysis Report ===")
        print(json.dumps(report, indent=2))

    # Show suggested configuration
    info("\n=== Suggested Preprocessing Configuration ===")
    print(json.dumps(config, indent=2))

    # Save to file if requested
    if args.output:
        with safe_open(args.output, "w") as f:
            json.dump(config, f, indent=2)
        success(f"\nConfiguration saved to: {args.output}")

    info(
        "\nTo use this configuration, create a preprocessing config in your conversion script."
    )
    info("Example usage in Python:")
    info("```python")
    info("from tools.mf1-html2md.preprocessors import PreprocessingConfig")
    info("config = PreprocessingConfig(**<loaded_json>)")
    info("```")


if __name__ == "__main__":
    main()

======= html2md_tool/api.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""High-level API for HTML to Markdown conversion."""

import asyncio
import sys
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from pathlib import Path
from typing import Dict, List, Optional, Union

# Import safe file operations
from m1f.file_operations import (
    safe_exists,
    safe_is_file,
    safe_is_dir,
    safe_mkdir,
    safe_open,
    safe_read_text,
    safe_write_text,
)

from rich.progress import Progress

# Use unified colorama module
from shared.colors import (
    Colors,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)

from html2md_tool.config import (
    Config,
    ConversionOptions,
    OutputFormat,
    ExtractorConfig,
    ProcessorConfig,
)
from html2md_tool.core import HTMLParser, MarkdownConverter
from html2md_tool.extractors import BaseExtractor, DefaultExtractor, load_extractor
from html2md_tool.utils import configure_logging, get_logger

logger = get_logger(__name__)


class Html2mdConverter:
    """Main API class for HTML to Markdown conversion."""

    def __init__(
        self,
        config: Union[Config, ConversionOptions, Dict, Path, str, None] = None,
        extractor: Optional[Union[BaseExtractor, Path, str]] = None,
    ):
        """Initialize converter with configuration.

        Args:
            config: Configuration object, ConversionOptions, dict, path to config file, or None
            extractor: Custom extractor instance, path to extractor file, or None
        """
        if config is None:
            self.config = Config(source=Path("."), destination=Path("."))
        elif isinstance(config, Config):
            self.config = config
        elif isinstance(config, ConversionOptions):
            # Create Config from ConversionOptions
            self.config = Config(
                source=Path(config.source_dir) if config.source_dir else Path("."),
                destination=(
                    config.destination_dir if config.destination_dir else Path(".")
                ),
                conversion=config,
            )
        elif isinstance(config, dict):
            self.config = Config(**config)
        elif isinstance(config, (Path, str)):
            from html2md_tool.config import load_config

            self.config = load_config(Path(config))
        else:
            raise TypeError(f"Invalid config type: {type(config)}")

        # Configure logging
        configure_logging(
            verbose=getattr(self.config, "verbose", False),
            quiet=getattr(self.config, "quiet", False),
            log_file=getattr(self.config, "log_file", None),
        )

        # Initialize components
        self._parser = HTMLParser(getattr(self.config, "extractor", ExtractorConfig()))
        self._converter = MarkdownConverter(
            getattr(self.config, "processor", ProcessorConfig())
        )
        # Console no longer needed with unified colorama

        # Initialize extractor
        if extractor is None:
            self._extractor = DefaultExtractor()
        elif isinstance(extractor, BaseExtractor):
            self._extractor = extractor
        elif isinstance(extractor, (Path, str)):
            self._extractor = load_extractor(Path(extractor))
        else:
            raise TypeError(f"Invalid extractor type: {type(extractor)}")

    def convert_html(
        self,
        html_content: str,
        base_url: Optional[str] = None,
        source_file: Optional[str] = None,
    ) -> str:
        """Convert HTML content to Markdown.

        Args:
            html_content: HTML content to convert
            base_url: Optional base URL for resolving relative links
            source_file: Optional source file name

        Returns:
            Markdown content
        """
        # Apply custom extractor preprocessing
        html_content = self._extractor.preprocess(html_content, self.config.__dict__)

        # Apply preprocessing if configured
        if hasattr(self.config, "preprocessing") and self.config.preprocessing:
            from html2md_tool.preprocessors import preprocess_html

            html_content = preprocess_html(html_content, self.config.preprocessing)

        # Parse HTML
        parsed = self._parser.parse(html_content, base_url)

        # IMPORTANT: Extract all H1 tags and title BEFORE any extraction or selector filtering
        # This ensures we capture H1s from header, nav, or any other area
        original_h1_tags = parsed.find_all("h1")
        h1_contents = []

        # Store all H1 contents from the original document
        for h1 in original_h1_tags:
            h1_text = h1.get_text(strip=True)
            if h1_text and h1_text not in h1_contents:  # Remove duplicates
                h1_contents.append(h1_text)

        # Get title as fallback
        title_content = None
        title_tag = parsed.find("title")
        if title_tag and title_tag.string:
            title_content = title_tag.string.strip()

        # Apply custom extractor AFTER we've saved H1s
        parsed = self._extractor.extract(parsed, self.config.__dict__)

        # Handle CSS selectors if specified (after extraction)
        if self.config.conversion.outermost_selector:
            from bs4 import BeautifulSoup

            selected = parsed.select_one(self.config.conversion.outermost_selector)
            if selected:
                # Remove ignored elements (but preserve H1)
                if self.config.conversion.ignore_selectors:
                    for selector in self.config.conversion.ignore_selectors:
                        # Skip H1 selector to preserve headings
                        if selector.lower() in ["h1", "h1.*", "*h1*"]:
                            continue
                        for elem in selected.select(selector):
                            # Double-check: don't remove H1 tags
                            if elem.name != "h1":
                                elem.decompose()
                # Create new soup from selected element
                parsed = BeautifulSoup(str(selected), "html.parser")

                # Check if H1 is still present after selection
                existing_h1s_after = parsed.find_all("h1")
                existing_h1_texts = [
                    h1.get_text(strip=True) for h1 in existing_h1s_after
                ]

                # Always ensure we have at least one H1
                if h1_contents:
                    # We had H1s in the original document
                    if not existing_h1s_after:
                        # All H1s were removed, restore them
                        new_h1 = parsed.new_tag("h1")
                        new_h1.string = h1_contents[0]
                        parsed.insert(0, new_h1)

                        # Add remaining H1s as H2
                        for h1_text in h1_contents[1:]:
                            new_h2 = parsed.new_tag("h2")
                            new_h2.string = h1_text
                            parsed.insert(1, new_h2)
                    else:
                        # Some H1s still exist, check if we need to add missing ones
                        for h1_text in h1_contents:
                            if h1_text not in existing_h1_texts:
                                # This H1 was removed, add it back as first element
                                new_h1 = parsed.new_tag("h1")
                                new_h1.string = h1_text
                                parsed.insert(0, new_h1)
                                break  # Only add the first missing H1
                elif not existing_h1s_after and title_content:
                    # No H1 at all in original, create one from title
                    new_h1 = parsed.new_tag("h1")
                    new_h1.string = title_content
                    parsed.insert(0, new_h1)
        else:
            # No outermost_selector, but still ensure H1 exists
            if not parsed.find("h1") and title_content:
                # No H1 in document, create one from title
                new_h1 = parsed.new_tag("h1")
                new_h1.string = title_content
                # Try to insert at the beginning of body, or just at the beginning
                body = parsed.find("body")
                if body:
                    body.insert(0, new_h1)
                else:
                    parsed.insert(0, new_h1)

        # Remove script and style tags that may have been missed
        for tag in parsed.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Handle multiple H1 tags - convert duplicates and additional H1s to H2
        all_h1s = parsed.find_all("h1")
        if len(all_h1s) > 1:
            seen_h1_texts = set()
            first_h1_kept = False

            for h1 in all_h1s:
                h1_text = h1.get_text(strip=True)

                # Remove duplicate H1s
                if h1_text in seen_h1_texts:
                    h1.decompose()
                    continue

                seen_h1_texts.add(h1_text)

                # Keep first unique H1, convert rest to H2
                if not first_h1_kept:
                    first_h1_kept = True
                else:
                    h1.name = "h2"

        # Apply heading offset if specified
        if self.config.conversion.heading_offset:
            for i in range(1, 7):
                for tag in parsed.find_all(f"h{i}"):
                    new_level = max(
                        1, min(6, i + self.config.conversion.heading_offset)
                    )
                    tag.name = f"h{new_level}"

        # Convert to markdown
        options = {}
        if self.config.conversion.code_language:
            options["code_language"] = self.config.conversion.code_language
        if self.config.conversion.heading_style:
            options["heading_style"] = self.config.conversion.heading_style

        markdown = self._converter.convert(parsed, options)

        # Add frontmatter if requested
        if self.config.conversion.generate_frontmatter:
            import yaml

            frontmatter = self.config.conversion.frontmatter_fields or {}

            # Extract title from HTML if not provided
            if "title" not in frontmatter:
                title_tag = parsed.find("title")
                if title_tag and title_tag.string:
                    frontmatter["title"] = title_tag.string.strip()

            # Add source file to frontmatter if provided
            if source_file and "source_file" not in frontmatter:
                frontmatter["source_file"] = source_file

            if frontmatter:
                fm_str = yaml.dump(frontmatter, default_flow_style=False)
                markdown = f"---\n{fm_str}---\n\n{markdown}"

        # Apply custom extractor postprocessing
        markdown = self._extractor.postprocess(markdown, self.config.__dict__)

        # Convert absolute file paths to relative links
        if source_file and hasattr(self.config, "destination"):
            markdown = self._convert_absolute_paths_to_relative(
                markdown, source_file, self.config.destination
            )

        # Adjust internal links to convert .html to .md
        from html2md_tool.utils import adjust_internal_links

        markdown = adjust_internal_links(markdown)

        return markdown

    def _convert_absolute_paths_to_relative(
        self, markdown: str, source_file: str, destination: Path
    ) -> str:
        """Convert absolute file paths in markdown to relative paths.

        Args:
            markdown: Markdown content
            source_file: Source HTML file path
            destination: Destination directory

        Returns:
            Markdown with relative paths
        """
        import re
        from pathlib import Path

        # Convert source_file to Path if it's a string
        if isinstance(source_file, str):
            source_file = Path(source_file)

        # Get the source directory
        source_dir = source_file.parent

        # Find all markdown links with absolute paths
        # Match patterns like [text](/absolute/path) or [text](file:///absolute/path)
        def replace_link(match):
            text = match.group(1)
            link = match.group(2)

            # Skip if it's already a relative link or external URL
            if link.startswith(("http://", "https://", "#", "mailto:", "../", "./")):
                return match.group(0)

            # Handle file:// URLs
            if link.startswith("file://"):
                link = link[7:]  # Remove file://
                # On Windows, file URLs might have an extra slash
                if link.startswith("/") and len(link) > 2 and link[2] == ":":
                    link = link[1:]

            # Handle paths starting with / (like /kb/1337/policy-syntax)
            # These should be converted to relative paths
            if link.startswith("/") and not link.startswith("//"):
                # Remove leading slash
                link_without_slash = link[1:]

                # Special handling for /kb/ links - remove the kb/ prefix if present
                if link_without_slash.startswith("kb/"):
                    link_without_slash = link_without_slash[3:]  # Remove 'kb/'

                # Check if this should point to an index.md file
                # If the path ends with a directory name (no extension), add /index.md
                parts = link_without_slash.split("/")
                last_part = parts[-1] if parts else ""
                if "." not in last_part and link_without_slash:
                    # This looks like a directory reference
                    link_without_slash = link_without_slash.rstrip("/") + "/index.md"
                elif not link_without_slash.endswith(".md") and "." not in last_part:
                    # Add .md extension for files
                    link_without_slash = link_without_slash + ".md"

                # Get current file's location relative to destination root
                current_file_path = Path(source_file)
                if hasattr(self, "config") and hasattr(self.config, "source"):
                    try:
                        if current_file_path.is_relative_to(self.config.source):
                            current_rel = current_file_path.relative_to(
                                self.config.source
                            )
                            current_dir = current_rel.parent

                            # Get the target path
                            target_path = Path(link_without_slash)

                            # Calculate relative path from current directory to target
                            if str(current_dir) != ".":
                                # Count how many levels up we need to go
                                levels_up = len(current_dir.parts)
                                # Create the relative path
                                relative_path = Path("../" * levels_up) / target_path
                                link = str(relative_path).replace("\\", "/")
                            else:
                                # We're at the root, so just use the path as-is
                                link = "./" + link_without_slash
                        else:
                            # Can't determine relative path, use simple approach
                            link = "./" + link_without_slash
                    except Exception:
                        # Fallback to simple relative path
                        link = "./" + link_without_slash
                else:
                    # No config available, use simple approach
                    link = "./" + link_without_slash

                return f"[{text}]({link})"

            # Convert to Path
            try:
                link_path = Path(link)

                # If it's an absolute path
                if link_path.is_absolute():
                    # Calculate relative path from destination to the linked file
                    # We need to go from where the markdown will be to where the linked file is

                    # First, get the output file path
                    relative_source = source_file.relative_to(source_dir.parent)
                    output_file = destination / relative_source.with_suffix(".md")
                    output_dir = output_file.parent

                    # Check if the linked file exists with .md extension
                    # (it's probably been converted from .html to .md)
                    md_link = link_path.with_suffix(".md")
                    if safe_exists(md_link) or link_path.suffix in [".html", ".htm"]:
                        # Use .md extension for converted files
                        link_path = link_path.with_suffix(".md")

                    # Calculate relative path from output directory to linked file
                    try:
                        # If the linked file is also in the destination
                        if str(link_path).startswith(str(destination)):
                            relative_link = link_path.relative_to(output_dir)
                        else:
                            # Try to map it based on source structure
                            # This handles cases where the link points to another HTML file
                            # that will also be converted
                            link_in_source = None
                            for ext in [".html", ".htm", ""]:
                                test_path = source_dir.parent / link_path.name
                                if ext:
                                    test_path = test_path.with_suffix(ext)
                                if safe_exists(test_path):
                                    link_in_source = test_path
                                    break

                            if link_in_source:
                                # Map to destination structure
                                relative_in_source = link_in_source.relative_to(
                                    source_dir.parent
                                )
                                link_in_dest = (
                                    destination / relative_in_source.with_suffix(".md")
                                )
                                relative_link = link_in_dest.relative_to(output_dir)
                            else:
                                # Fallback: try to make it relative if possible
                                relative_link = link_path.relative_to(output_dir)

                        # Convert to string with forward slashes
                        link = str(relative_link).replace("\\", "/")

                    except ValueError:
                        # Can't make relative - keep as is but remove file://
                        link = str(link_path)

            except Exception:
                # If anything goes wrong, return original match
                return match.group(0)

            return f"[{text}]({link})"

        # Replace markdown links
        markdown = re.sub(r"\[([^\]]+)\]\(([^)]+)\)", replace_link, markdown)

        return markdown

    async def convert_directory_from_urls(self, urls: List[str]) -> List[Path]:
        """Convert multiple URLs in parallel.

        Args:
            urls: List of URLs to convert

        Returns:
            List of output file paths
        """
        # Simple implementation for tests
        results = []
        for url in urls:
            # Actually convert the URL
            output_path = self.convert_url(url)
            results.append(output_path)
        return results

    def convert_file(self, file_path: Path) -> Path:
        """Convert a single HTML file to Markdown.

        Args:
            file_path: Path to HTML file

        Returns:
            Path to generated Markdown file
        """
        # Validate path to prevent traversal attacks
        file_path = self._validate_path(file_path, self.config.source)

        logger.debug(f"Converting {file_path}")

        # Read file content
        try:
            with safe_open(file_path, "r", encoding="utf-8") as f:
                html_content = f.read()
        except UnicodeDecodeError:
            # Try with different encodings
            for encoding in ["latin-1", "cp1252"]:
                try:
                    with safe_open(file_path, "r", encoding=encoding) as f:
                        html_content = f.read()
                    break
                except UnicodeDecodeError:
                    continue
            else:
                # Last resort - ignore errors
                with safe_open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    html_content = f.read()

        # Convert using the convert_html method which includes preprocessing
        # Use a relative base URL to avoid exposing absolute paths
        file_name = (
            file_path.name
            if file_path and file_path.name
            else (Path(file_path).resolve().name if file_path else None)
        )
        base_url = file_name
        markdown = self.convert_html(
            html_content,
            base_url=base_url,
            source_file=str(
                file_path
            ),  # Pass full path for proper relative link calculation
        )

        # Determine output path
        # Resolve both paths to handle cases where source is "."
        resolved_file = file_path.resolve()
        resolved_source = self.config.source.resolve()

        try:
            # Try to get relative path from resolved paths
            rel_path = resolved_file.relative_to(resolved_source)
        except ValueError:
            # If that fails, try with the original paths
            try:
                if file_path.is_relative_to(self.config.source):
                    rel_path = file_path.relative_to(self.config.source)
                else:
                    # Last resort - just use the filename
                    rel_path = Path(file_path.name)
            except:
                # Ultimate fallback
                rel_path = Path(file_path.name if file_path.name else "output")

        output_path = self.config.destination / Path(rel_path).with_suffix(".md")

        # Validate output path to ensure it stays within destination directory
        output_path = self._validate_output_path(output_path, self.config.destination)

        safe_mkdir(output_path.parent, parents=True, exist_ok=True)

        # Write file
        safe_write_text(output_path, markdown, encoding=self.config.target_encoding)

        logger.debug(f"Written to {output_path}")
        return output_path

    def convert_directory(
        self, source_dir: Optional[Path] = None, recursive: bool = True
    ) -> List[Path]:
        """Convert all HTML files in a directory.

        Args:
            source_dir: Source directory (uses config if not specified)
            recursive: Whether to search recursively

        Returns:
            List of generated Markdown files
        """
        source_dir = source_dir or self.config.source

        # Validate source directory
        source_dir = self._validate_path(source_dir, self.config.source)

        # Find HTML files
        pattern = "**/*" if recursive else "*"
        html_files = []

        for ext in self.config.file_extensions:
            html_files.extend(source_dir.glob(f"{pattern}{ext}"))

        # Filter excluded patterns
        if self.config.exclude_patterns:
            import fnmatch

            filtered = []
            for file in html_files:
                excluded = False
                for pattern in self.config.exclude_patterns:
                    if fnmatch.fnmatch(str(file), pattern):
                        excluded = True
                        break
                if not excluded:
                    filtered.append(file)
            html_files = filtered

        if not self.config.quiet:
            logger.info(f"Found {len(html_files)} files to convert")

        # Convert files
        if self.config.parallel and len(html_files) > 1:
            return self._convert_parallel(html_files)
        else:
            return self._convert_sequential(html_files)

    def convert_url(self, url: str) -> Path:
        """Convert a web page to Markdown.

        Args:
            url: URL to convert

        Returns:
            Path to generated Markdown file
        """
        import requests
        from urllib.parse import urlparse

        logger.info(f"Fetching {url}")

        # Fetch HTML
        response = requests.get(url)
        response.raise_for_status()

        # Convert HTML to Markdown
        markdown = self.convert_html(response.text, base_url=url)

        # Determine output filename
        parsed_url = urlparse(url)
        path_parts = parsed_url.path.strip("/").split("/")
        filename = path_parts[-1] if path_parts and path_parts[-1] else "index"
        if not filename.endswith(".md"):
            filename = filename.replace(".html", "") + ".md"
        output_path = Path(self.config.destination) / filename
        safe_mkdir(output_path.parent, parents=True, exist_ok=True)

        # Write file
        encoding = getattr(self.config, "target_encoding", "utf-8")
        safe_write_text(output_path, markdown, encoding=encoding)

        logger.info(f"Saved to {output_path}")
        return output_path

    def convert_website(self, start_url: str) -> Dict[str, Path]:
        """Convert an entire website to Markdown.

        DEPRECATED: Use the m1f-scrape tool to download websites first,
        then use convert_directory to convert the downloaded HTML files.

        Args:
            start_url: Starting URL for crawling

        Returns:
            Dictionary mapping source files to generated markdown files
        """
        logger.warning(
            "convert_website is deprecated. Use m1f-scrape tool for downloading."
        )
        logger.info(f"Website conversion starting from {start_url}")

        # Import crawler from m1f-scrape module
        raise NotImplementedError(
            "Website crawling has been moved to the m1f-scrape tool. "
            "Please use: m1f-scrape <url> -o <output_dir>"
        )

    async def convert_website_async(self, start_url: str) -> Dict[str, Path]:
        """Async version of convert_website for backward compatibility.

        Args:
            start_url: Starting URL for crawling

        Returns:
            Dictionary mapping URLs to generated files
        """
        # HTTrack runs synchronously, so we just wrap the sync method
        return self.convert_website(start_url)

    def _convert_sequential(self, files: List[Path]) -> List[Path]:
        """Convert files sequentially."""
        results = []

        with Progress() as progress:
            task = progress.add_task("Converting files...", total=len(files))

            for file in files:
                try:
                    output = self.convert_file(file)
                    results.append(output)
                except Exception as e:
                    logger.error(f"Failed to convert {file}: {e}")
                finally:
                    progress.update(task, advance=1)

        return results

    def _convert_parallel(self, files: List[Path]) -> List[Path]:
        """Convert files in parallel."""
        results = []
        max_workers = self.config.max_workers or None

        with Progress() as progress:
            task = progress.add_task("Converting files...", total=len(files))

            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                futures = {
                    executor.submit(self._convert_file_wrapper, file): file
                    for file in files
                }

                for future in futures:
                    try:
                        output = future.result()
                        if output:
                            results.append(output)
                    except Exception as e:
                        logger.error(f"Failed to convert {futures[future]}: {e}")
                    finally:
                        progress.update(task, advance=1)

        return results

    def _convert_file_wrapper(self, file_path: Path) -> Optional[Path]:
        """Wrapper for parallel processing."""
        try:
            # Validate input path
            file_path = self._validate_path(file_path, self.config.source)

            # Read file content
            try:
                with safe_open(file_path, "r", encoding="utf-8") as f:
                    html_content = f.read()
            except UnicodeDecodeError:
                # Try with different encodings
                for encoding in ["latin-1", "cp1252"]:
                    try:
                        with safe_open(file_path, "r", encoding=encoding) as f:
                            html_content = f.read()
                        break
                    except UnicodeDecodeError:
                        continue
                else:
                    # Last resort - ignore errors
                    with safe_open(
                        file_path, "r", encoding="utf-8", errors="ignore"
                    ) as f:
                        html_content = f.read()

            # Convert using the convert_html method which includes all preprocessing and CSS selector logic
            # Use a relative base URL to avoid exposing absolute paths
            file_name = (
                file_path.name
                if file_path and file_path.name
                else (Path(file_path).resolve().name if file_path else None)
            )
            base_url = file_name
            markdown = self.convert_html(
                html_content,
                base_url=base_url,
                source_file=str(
                    file_path
                ),  # Pass full path for proper relative link calculation
            )

            # Determine output path
            # Resolve both paths to handle cases where source is "."
            resolved_file = file_path.resolve()
            resolved_source = self.config.source.resolve()

            try:
                # Try to get relative path from resolved paths
                rel_path = resolved_file.relative_to(resolved_source)
            except ValueError:
                # If that fails, try with the original paths
                try:
                    if file_path.is_relative_to(self.config.source):
                        rel_path = file_path.relative_to(self.config.source)
                    else:
                        # Last resort - just use the filename
                        rel_path = Path(file_path.name)
                except:
                    # Ultimate fallback
                    rel_path = Path(file_path.name if file_path.name else "output")

            output_path = self.config.destination / Path(rel_path).with_suffix(".md")

            # Validate output path
            output_path = self._validate_output_path(
                output_path, self.config.destination
            )

            safe_mkdir(output_path.parent, parents=True, exist_ok=True)
            safe_write_text(output_path, markdown, encoding=self.config.target_encoding)

            return output_path
        except Exception as e:
            logger.error(f"Error in worker: {e}")
            return None

    def generate_m1f_bundle(self) -> Path:
        """Generate an m1f bundle from converted files.

        Returns:
            Path to generated m1f bundle
        """
        if not self.config.m1f.create_bundle:
            raise ValueError("m1f bundle creation not enabled in config")

        logger.info("Generating m1f bundle...")

        # Import m1f integration
        from html2md_tool.processors.m1f_integration import M1FBundler

        bundler = M1FBundler(self.config.m1f)
        bundle_path = bundler.create_bundle(
            self.config.destination, bundle_name=self.config.m1f.bundle_name
        )

        logger.info(f"Created m1f bundle: {bundle_path}")
        return bundle_path

    def _validate_path(self, path: Path, base_path: Path) -> Path:
        """Validate that a path does not traverse outside allowed directories.

        Args:
            path: The path to validate
            base_path: The base directory that the path must be within

        Returns:
            The validated resolved path

        Raises:
            ValueError: If the path attempts directory traversal
        """
        # Resolve both paths to absolute
        resolved_path = path.resolve()
        resolved_base = base_path.resolve()

        # Check for suspicious traversal patterns in the original path
        path_str = str(path)

        # Check for excessive parent directory traversals
        parent_traversals = path_str.count("../")
        if parent_traversals >= 3:
            raise ValueError(
                f"Path traversal detected: '{path}' contains suspicious '..' patterns"
            )

        # Ensure the resolved path is within the base directory
        try:
            resolved_path.relative_to(resolved_base)
            return resolved_path
        except ValueError:
            # Check if we're in a test environment
            if any(
                part in str(resolved_path)
                for part in ["/tmp/", "/var/folders/", "pytest-", "test_"]
            ):
                # Allow temporary test directories
                return resolved_path

            raise ValueError(
                f"Path traversal detected: '{path}' resolves to '{resolved_path}' "
                f"which is outside the allowed directory '{resolved_base}'"
            )

    def _validate_output_path(self, output_path: Path, destination_base: Path) -> Path:
        """Validate that an output path stays within the destination directory.

        Args:
            output_path: The output path to validate
            destination_base: The destination base directory

        Returns:
            The validated resolved path

        Raises:
            ValueError: If the path would escape the destination directory
        """
        # Resolve both paths
        resolved_output = output_path.resolve()
        resolved_dest = destination_base.resolve()

        # Ensure output is within destination
        try:
            resolved_output.relative_to(resolved_dest)
            return resolved_output
        except ValueError:
            # Check if we're in a test environment
            if any(
                part in str(resolved_output)
                for part in ["/tmp/", "/var/folders/", "pytest-", "test_"]
            ):
                return resolved_output

            raise ValueError(
                f"Output path '{output_path}' would escape destination directory '{resolved_dest}'"
            )


# Convenience functions
def convert_file(file_path: Union[str, Path], **kwargs) -> Path:
    """Convert a single HTML file to Markdown.

    Args:
        file_path: Path to HTML file
        **kwargs: Additional configuration options

    Returns:
        Path to generated Markdown file
    """
    config = Config(
        source=Path(file_path).parent,
        destination=kwargs.pop("destination", Path(".")),
        **kwargs,
    )
    converter = Html2mdConverter(config)
    return converter.convert_file(Path(file_path))


def convert_directory(
    source_dir: Union[str, Path], destination_dir: Union[str, Path], **kwargs
) -> List[Path]:
    """Convert all HTML files in a directory to Markdown.

    Args:
        source_dir: Source directory containing HTML files
        destination_dir: Destination directory for Markdown files
        **kwargs: Additional configuration options

    Returns:
        List of generated Markdown files
    """
    config = Config(
        source=Path(source_dir), destination=Path(destination_dir), **kwargs
    )
    converter = Html2mdConverter(config)
    return converter.convert_directory()


def convert_url(url: str, destination_dir: Union[str, Path] = ".", **kwargs) -> Path:
    """Convert a web page to Markdown.

    Args:
        url: URL to convert
        destination_dir: Destination directory
        **kwargs: Additional configuration options

    Returns:
        Path to generated Markdown file
    """
    config = Config(
        source=Path("."),  # Not used for URL conversion
        destination=Path(destination_dir),
        **kwargs,
    )
    converter = Html2mdConverter(config)
    return converter.convert_url(url)


def convert_html(html_content: str, **kwargs) -> str:
    """Convert HTML content to Markdown.

    Args:
        html_content: HTML content to convert
        **kwargs: Additional options

    Returns:
        Markdown content
    """
    from pathlib import Path
    from html2md_tool.config.models import ConversionOptions, Config

    # Create minimal config
    config = Config(
        source=Path("."),
        destination=Path("."),
    )

    # Apply conversion options
    if kwargs:
        for key, value in kwargs.items():
            if hasattr(config.conversion, key):
                setattr(config.conversion, key, value)

    converter = Html2mdConverter(config)
    return converter.convert_html(html_content)

======= html2md_tool/claude_runner.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Claude runner with reliable subprocess execution and streaming support.
"""

import subprocess
import sys
import os
import json
import threading
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# Import safe file operations
from m1f.file_operations import safe_exists, safe_is_file

# Use unified colorama module
from shared.colors import (
    Colors,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)

# Import shared Claude utilities
from shared.claude_utils import (
    ClaudeBinaryFinder,
    ClaudeErrorHandler,
    ClaudeConfig,
    ClaudeRunner as BaseClaudeRunner,
)


class ClaudeRunner(BaseClaudeRunner):
    """Handles Claude CLI execution with reliable subprocess support."""

    def __init__(
        self,
        max_workers: int = 5,
        working_dir: Optional[str] = None,
        claude_binary: Optional[str] = None,
        config: Optional[ClaudeConfig] = None,
    ):
        super().__init__(config=config, binary_path=claude_binary)
        self.max_workers = max_workers
        self.working_dir = working_dir or str(Path.cwd())

    def run_claude_simple(
        self,
        prompt: str,
        allowed_tools: str = "Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write",
        add_dir: Optional[str] = None,
        timeout: int = 300,
        show_output: bool = False,
    ) -> Tuple[int, str, str]:
        """
        Run Claude using simple subprocess approach with better timeout handling.

        Returns: (returncode, stdout, stderr)
        """
        cmd = [
            self.get_binary(),
            "--print",  # Use print mode for non-interactive output
            "--allowedTools",
            allowed_tools,
        ]

        # Add working directory to command if different from current
        if add_dir:
            cmd.extend(["--add-dir", add_dir])

        # Set environment to ensure unbuffered output
        env = os.environ.copy()
        env["PYTHONUNBUFFERED"] = "1"

        if show_output:
            info(f"{Colors.BLUE}🤖 Running Claude...{Colors.RESET}")
            info(f"{Colors.DIM}Command: {' '.join(cmd[:3])} ...{Colors.RESET}")
            info(f"{Colors.DIM}Working dir: {self.working_dir}{Colors.RESET}")

        try:
            # Use a more conservative timeout for complex tasks
            actual_timeout = max(60, timeout)  # At least 60 seconds

            # Run the process with timeout
            result = subprocess.run(
                cmd,
                input=prompt,
                capture_output=True,
                text=True,
                timeout=actual_timeout,
                env=env,
                cwd=self.working_dir,
            )

            if show_output:
                if result.returncode == 0:
                    success("Claude processing complete")
                else:
                    error(f"Claude failed with code {result.returncode}")
                    if result.stderr:
                        error(
                            f"{Colors.DIM}Error: {result.stderr[:200]}...{Colors.RESET}"
                        )

            return result.returncode, result.stdout, result.stderr

        except subprocess.TimeoutExpired:
            warning(f"⏰ Claude timed out after {actual_timeout}s")
            info(
                f"{Colors.BLUE}💡 Try increasing timeout or simplifying the task{Colors.RESET}"
            )
            return -1, "", f"Process timed out after {actual_timeout}s"
        except Exception as e:
            self.error_handler.handle_api_error(e, operation="Claude simple")
            return -1, "", str(e)

    def run_claude_streaming(
        self,
        prompt: str,
        allowed_tools: str = "Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write",
        add_dir: Optional[str] = None,
        timeout: int = 300,
        show_output: bool = False,
        working_dir: Optional[str] = None,
    ) -> Tuple[int, str, str]:
        """
        Run Claude with real-time streaming output.

        Returns: (returncode, stdout, stderr)
        """
        # Use the working_dir parameter if provided, otherwise use instance default
        work_dir = working_dir if working_dir is not None else self.working_dir

        # Build command
        cmd = [self.get_binary(), "-p", "--allowedTools", allowed_tools]

        if add_dir:
            cmd.extend(["--add-dir", add_dir])

        # Only show initial message if show_output is enabled
        # Removed verbose output for cleaner interface

        # Collect all output
        stdout_lines = []
        stderr_lines = []

        try:
            # Start the process
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=work_dir,
                text=True,
                bufsize=1,
                universal_newlines=True,
            )

            # Send the prompt and close stdin
            process.stdin.write(prompt)
            process.stdin.close()

            # Track timing
            start_time = time.time()
            last_output_time = start_time

            # Read stdout line by line
            while True:
                line = process.stdout.readline()
                if line == "" and process.poll() is not None:
                    break
                if line:
                    line = line.rstrip()
                    stdout_lines.append(line)

                    if show_output:
                        current_time = time.time()
                        elapsed = current_time - start_time
                        # Show Claude's actual output (no truncation, terminal will soft wrap)
                        info(f"[{elapsed:.1f}s] {line}")
                        last_output_time = current_time

                # Check timeout
                if time.time() - start_time > timeout:
                    process.kill()
                    if show_output:
                        warning(f"⏰ Claude timed out after {timeout}s")
                    return -1, "\n".join(stdout_lines), "Process timed out"

            # Get any remaining output
            try:
                remaining_stdout, stderr = process.communicate(timeout=5)
                if remaining_stdout:
                    stdout_lines.extend(remaining_stdout.splitlines())
                if stderr:
                    stderr_lines.extend(stderr.splitlines())
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
            except ValueError:
                # Ignore "I/O operation on closed file" errors
                stderr = ""

            # Join all output
            stdout = "\n".join(stdout_lines)
            stderr = "\n".join(stderr_lines)

            if show_output:
                total_time = time.time() - start_time
                if process.returncode == 0:
                    success("Claude processing complete")
                else:
                    error(f"Claude failed with code {process.returncode}")
                    if stderr:
                        error(f"{Colors.DIM}Error: {stderr[:200]}...{Colors.RESET}")

            return process.returncode, stdout, stderr

        except Exception as e:
            if show_output:
                self.error_handler.handle_api_error(e, operation="Claude streaming")
            return -1, "\n".join(stdout_lines), str(e)

    def run_claude_streaming_json(
        self,
        prompt: str,
        allowed_tools: str = "Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write,Task",
        add_dir: Optional[str] = None,
        timeout: int = 600,
        working_dir: Optional[str] = None,
        show_progress: bool = True,
    ) -> Tuple[int, str, str]:
        """
        Run Claude with stream-json output format and real-time progress display.

        Returns: (returncode, stdout, stderr)
        """
        # Use working directory if provided
        work_dir = working_dir or self.working_dir

        # Build command with stream-json format
        cmd = [
            self.get_binary(),
            "-p",
            "--output-format",
            "stream-json",
            "--allowedTools",
            allowed_tools,
            "--verbose",  # Required for stream-json with -p
        ]

        if add_dir:
            cmd.extend(["--add-dir", add_dir])

        # Set environment for unbuffered output
        env = os.environ.copy()
        env["PYTHONUNBUFFERED"] = "1"

        if show_progress:
            info(
                f"{Colors.BLUE}🤖 Starting Claude with real-time streaming...{Colors.RESET}"
            )

        # Collect all output
        stdout_lines = []
        stderr_lines = []

        try:
            # Start the process
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=work_dir,
                text=True,
                bufsize=1,  # Line buffered
                universal_newlines=True,
                env=env,
            )

            # Send the prompt and close stdin
            process.stdin.write(prompt)
            process.stdin.close()

            # Create thread to read stderr
            def read_stderr():
                while True:
                    err_line = process.stderr.readline()
                    if not err_line:
                        break
                    stderr_lines.append(err_line.strip())
                    if show_progress and err_line.strip():
                        warning(f"⚠️  {err_line.strip()}")

            stderr_thread = threading.Thread(target=read_stderr)
            stderr_thread.start()

            # Track timing
            start_time = time.time()

            if show_progress:
                info("🔄 Processing with Claude (streaming output)...")

            # Read stdout line by line and parse JSON in real-time
            while True:
                line = process.stdout.readline()
                if not line and process.poll() is not None:
                    break

                if line:
                    line = line.strip()
                    stdout_lines.append(line)

                    # Parse and display progress in real-time
                    if line and show_progress:
                        try:
                            json_obj = json.loads(line)
                            self._display_claude_progress(json_obj, start_time)
                        except json.JSONDecodeError:
                            # Not a JSON line, might be other output
                            if line and not line.startswith("Running command:"):
                                info(
                                    f"{Colors.DIM}Raw: {line[:100]}{'...' if len(line) > 100 else ''}{Colors.RESET}"
                                )

                # Check timeout
                if time.time() - start_time > timeout:
                    process.kill()
                    if show_progress:
                        warning(f"⏰ Claude timed out after {timeout}s")
                    return -1, "\n".join(stdout_lines), "Process timed out"

            # Wait for process to complete
            process.wait()

            # Wait for stderr thread to finish
            stderr_thread.join()

            # Join all output
            stdout = "\n".join(stdout_lines)
            stderr = "\n".join(stderr_lines)

            if show_progress:
                total_time = time.time() - start_time
                if process.returncode == 0:
                    success(f"✅ Claude processing complete ({total_time:.1f}s)")
                else:
                    error(f"❌ Claude failed with code {process.returncode}")
                    if stderr:
                        error(f"{Colors.DIM}Error: {stderr[:200]}...{Colors.RESET}")

            return process.returncode, stdout, stderr

        except Exception as e:
            if show_progress:
                self.error_handler.handle_api_error(
                    e, operation="Claude JSON streaming"
                )
            return -1, "\n".join(stdout_lines), str(e)

    def _display_claude_progress(self, json_obj: Dict[str, Any], start_time: float):
        """Display friendly progress messages based on Claude's JSON output."""
        msg_type = json_obj.get("type", "unknown")
        elapsed = time.time() - start_time

        if msg_type == "system" and json_obj.get("subtype") == "init":
            info("🚀 Starting conversation with Claude")
        elif msg_type == "assistant":
            # Handle assistant messages
            message = json_obj.get("message", {})
            if isinstance(message, dict):
                content_parts = message.get("content", [])
                if isinstance(content_parts, list):
                    for part in content_parts:
                        if isinstance(part, dict):
                            if part.get("type") == "text":
                                text = part.get("text", "")
                                # Extract meaningful actions from assistant messages
                                if "Task tool" in text or "Task(" in text:
                                    info(
                                        f"[{elapsed:.0f}s] 🔍 Claude is launching a subagent..."
                                    )
                                elif "Edit tool" in text or "Edit(" in text:
                                    info(
                                        f"[{elapsed:.0f}s] ✏️  Claude is editing files..."
                                    )
                                elif "Read tool" in text or "Read(" in text:
                                    info(
                                        f"[{elapsed:.0f}s] 📖 Claude is reading files..."
                                    )
                                elif (
                                    "Grep tool" in text
                                    or "Grep(" in text
                                    or "search" in text.lower()
                                ):
                                    info(
                                        f"[{elapsed:.0f}s] 🔎 Claude is searching for content..."
                                    )
                                elif "TodoWrite" in text:
                                    info(
                                        f"[{elapsed:.0f}s] 📝 Claude is managing tasks..."
                                    )
                                elif "Write tool" in text or "Write(" in text:
                                    info(
                                        f"[{elapsed:.0f}s] 💾 Claude is writing files..."
                                    )
                                elif len(text) > 50:  # Significant text output
                                    info(f"[{elapsed:.0f}s] 💭 Claude is analyzing...")
                            elif part.get("type") == "tool_use":
                                # Handle inline tool calls in assistant messages
                                tool_name = part.get("name", "unknown")
                                tool_input = part.get("input", {})

                                if tool_name == "Edit":
                                    file_path = tool_input.get("file_path", "")
                                    file_name = (
                                        os.path.basename(file_path)
                                        if file_path
                                        else "file"
                                    )
                                    info(f"[{elapsed:.0f}s] ✏️  Editing: {file_name}")
                                elif tool_name == "MultiEdit":
                                    file_path = tool_input.get("file_path", "")
                                    edits_count = len(tool_input.get("edits", []))
                                    file_name = (
                                        os.path.basename(file_path)
                                        if file_path
                                        else "file"
                                    )
                                    info(
                                        f"[{elapsed:.0f}s] ✏️  Making {edits_count} edits to: {file_name}"
                                    )
                                elif tool_name == "Read":
                                    file_path = tool_input.get("file_path", "")
                                    file_name = (
                                        os.path.basename(file_path)
                                        if file_path
                                        else "file"
                                    )
                                    info(f"[{elapsed:.0f}s] 📖 Reading: {file_name}")
                                elif tool_name == "Task":
                                    desc = tool_input.get("description", "")
                                    agent_type = tool_input.get(
                                        "subagent_type", "general"
                                    )
                                    info(
                                        f"[{elapsed:.0f}s] 🤖 Launching {agent_type} subagent: {desc[:50]}{'...' if len(desc) > 50 else ''}"
                                    )
                                elif tool_name == "Grep":
                                    pattern = tool_input.get("pattern", "")
                                    path = tool_input.get("path", ".")
                                    info(
                                        f"[{elapsed:.0f}s] 🔎 Searching for '{pattern[:30]}{'...' if len(pattern) > 30 else ''}' in {os.path.basename(path)}"
                                    )
                                elif tool_name == "TodoWrite":
                                    todos = tool_input.get("todos", [])
                                    info(
                                        f"[{elapsed:.0f}s] 📝 Managing {len(todos)} tasks"
                                    )
                                elif tool_name == "Write":
                                    file_path = tool_input.get("file_path", "")
                                    file_name = (
                                        os.path.basename(file_path)
                                        if file_path
                                        else "file"
                                    )
                                    info(f"[{elapsed:.0f}s] 💾 Writing: {file_name}")
                                elif tool_name == "Glob":
                                    pattern = tool_input.get("pattern", "")
                                    info(
                                        f"[{elapsed:.0f}s] 📁 Finding files: {pattern}"
                                    )
                                elif tool_name == "LS":
                                    path = tool_input.get("path", "")
                                    info(
                                        f"[{elapsed:.0f}s] 📂 Listing: {os.path.basename(path) if path else 'directory'}"
                                    )
                                else:
                                    info(f"[{elapsed:.0f}s] 🔧 Using tool: {tool_name}")
        elif msg_type == "result":
            if json_obj.get("subtype") == "success":
                success(f"[{elapsed:.0f}s] ✅ Task completed successfully")
            else:
                warning(f"[{elapsed:.0f}s] ❌ Task failed")
        elif msg_type == "user":
            # Skip displaying user messages (the prompt) unless it's a tool result
            parent_id = json_obj.get("parent_tool_use_id")
            if parent_id:
                info(f"[{elapsed:.0f}s]   ↳ Tool result received")

    def run_claude_parallel(
        self, tasks: List[Dict[str, Any]], show_progress: bool = True
    ) -> List[Dict[str, Any]]:
        """
        Run multiple Claude tasks in parallel using SDK.

        Args:
            tasks: List of task dictionaries with keys:
                - prompt: The prompt to send
                - name: Task name for display
                - allowed_tools: Tools to allow (optional)
                - add_dir: Directory to add (optional)
                - timeout: Timeout in seconds (optional)

        Returns:
            List of results with keys:
                - name: Task name
                - success: Boolean
                - returncode: Process return code
                - stdout: Standard output
                - stderr: Standard error
                - error: Error message if failed
        """
        results = []
        start_time = time.time()

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tasks
            future_to_task = {}
            for task in tasks:
                future = executor.submit(
                    self.run_claude_streaming,
                    prompt=task["prompt"],
                    allowed_tools=task.get(
                        "allowed_tools",
                        "Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write",
                    ),
                    add_dir=task.get("add_dir"),
                    timeout=task.get("timeout", 300),
                    show_output=show_progress,  # Show output if progress enabled
                    working_dir=task.get("working_dir"),
                )
                future_to_task[future] = task

            # Process completed tasks
            completed = 0
            total = len(tasks)

            for future in as_completed(future_to_task):
                task = future_to_task[future]
                completed += 1

                if show_progress:
                    elapsed_time = (
                        time.time() - start_time if "start_time" in locals() else 0
                    )
                    info(
                        f"{Colors.BLUE}📊 Progress: {completed}/{total} tasks completed [{elapsed_time:.0f}s elapsed]{Colors.RESET}"
                    )

                try:
                    returncode, stdout, stderr = future.result()

                    result = {
                        "name": task["name"],
                        "success": returncode == 0,
                        "returncode": returncode,
                        "stdout": stdout,
                        "stderr": stderr,
                        "error": None,
                    }

                    if returncode == 0:
                        success(f"Completed: {task['name']}")
                    else:
                        error(f"Failed: {task['name']}")

                except Exception as e:
                    error(f"Exception in {task['name']}: {e}")
                    result = {
                        "name": task["name"],
                        "success": False,
                        "returncode": -1,
                        "stdout": "",
                        "stderr": "",
                        "error": str(e),
                    }

                results.append(result)

        return results

======= html2md_tool/claude_runner_simple.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Simplified Claude runner for debugging.
"""

import subprocess
import os
import sys
from pathlib import Path
from typing import Tuple, Optional

# Import safe file operations
from m1f.file_operations import safe_exists, safe_is_file

# Use unified colorama module
from shared.colors import (
    Colors,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)


class ClaudeRunnerSimple:
    """Simplified Claude runner without streaming."""

    def __init__(self, claude_binary: Optional[str] = None):
        self.claude_binary = claude_binary or self._find_claude_binary()

    def _find_claude_binary(self) -> str:
        """Find Claude binary in system."""
        # Check known locations
        claude_paths = [
            Path.home() / ".claude" / "local" / "claude",
            Path("/usr/local/bin/claude"),
            Path("/usr/bin/claude"),
        ]

        for path in claude_paths:
            if safe_exists(path) and safe_is_file(path):
                return str(path)

        # Try default command
        try:
            subprocess.run(
                ["claude", "--version"], capture_output=True, check=True, timeout=5
            )
            return "claude"
        except:
            pass

        raise FileNotFoundError("Claude CLI not found")

    def run_claude(
        self,
        prompt: str,
        allowed_tools: str = "Read,Glob,Grep,Write",
        add_dir: Optional[str] = None,
        timeout: int = 300,
        working_dir: Optional[str] = None,
    ) -> Tuple[int, str, str]:
        """Run Claude with simple subprocess."""

        cmd = [
            self.claude_binary,
            "--print",
            "--allowedTools",
            allowed_tools,
        ]

        if add_dir:
            cmd.extend(["--add-dir", add_dir])

        # Add prompt as command argument
        cmd.extend(["--", prompt])

        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=timeout, cwd=working_dir
            )

            return result.returncode, result.stdout, result.stderr

        except subprocess.TimeoutExpired:
            return -1, "", f"Command timed out after {timeout} seconds"
        except Exception as e:
            return -1, "", str(e)

======= html2md_tool/cli.py ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Command-line interface for HTML to Markdown converter."""

import argparse
import sys
from pathlib import Path
from typing import List, Optional
from collections import Counter

# Import statements using absolute imports
from m1f.file_operations import (
    safe_exists,
    safe_is_file,
    safe_is_dir,
    safe_mkdir,
    safe_open,
    safe_read_text,
    safe_write_text,
)
from shared.colors import (
    Colors,
    ColoredHelpFormatter,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)
from shared.cli import CustomArgumentParser
from html2md_tool import __version__
from html2md_tool.api import Html2mdConverter
from html2md_tool.config import Config, OutputFormat
from html2md_tool.claude_runner import ClaudeRunner


def create_parser() -> CustomArgumentParser:
    """Create the argument parser."""
    description = """m1f-html2md - HTML to Markdown Converter
=====================================

Convert HTML files to clean Markdown format with advanced content extraction options.
Supports both local processing and Claude AI-powered conversion for optimal results.

Perfect for:
• Converting scraped documentation to readable Markdown
• Extracting main content from complex HTML layouts
• Batch processing entire documentation sites
• AI-powered intelligent content extraction"""

    epilog = """Examples:
  %(prog)s convert file.html -o file.md
  %(prog)s convert ./html/ -o ./markdown/
  %(prog)s convert ./html/ -c config.yaml
  %(prog)s convert ./html/ -o ./md/ --content-selector "article.post"
  %(prog)s analyze ./html/ --claude
  %(prog)s analyze ./html/ --claude --analyze-files 10
  %(prog)s convert ./html/ -o ./markdown/ --claude --model opus
  
For more information, see the documentation."""

    parser = CustomArgumentParser(
        prog="m1f-html2md",
        description=description,
        epilog=epilog,
        formatter_class=ColoredHelpFormatter,
        add_help=True,
    )

    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
        help="Show program version and exit",
    )

    # Output control group
    output_group = parser.add_argument_group("Output Control")
    output_group.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output"
    )
    output_group.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress all output except errors"
    )
    output_group.add_argument("--log-file", type=Path, help="Write logs to file")

    # Subcommands
    subparsers = parser.add_subparsers(
        dest="command",
        help="Available commands",
        required=True,
        metavar="COMMAND",
    )

    # Convert command
    convert_parser = subparsers.add_parser(
        "convert",
        help="Convert HTML files to Markdown",
        formatter_class=ColoredHelpFormatter,
    )
    add_convert_arguments(convert_parser)

    # Analyze command
    analyze_parser = subparsers.add_parser(
        "analyze",
        help="Analyze HTML structure for content extraction",
        formatter_class=ColoredHelpFormatter,
    )
    add_analyze_arguments(analyze_parser)

    # Config command
    config_parser = subparsers.add_parser(
        "config",
        help="Generate configuration file template",
        formatter_class=ColoredHelpFormatter,
    )
    add_config_arguments(config_parser)

    return parser


def add_convert_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for convert command."""
    # Positional arguments
    parser.add_argument("source", type=Path, help="Source HTML file or directory")
    parser.add_argument(
        "-o", "--output", type=Path, required=True, help="Output file or directory"
    )

    # Configuration group
    config_group = parser.add_argument_group("Configuration")
    config_group.add_argument(
        "-c", "--config", type=Path, help="Configuration file (YAML/JSON/TOML)"
    )
    config_group.add_argument(
        "--format",
        choices=["markdown", "m1f_bundle", "json"],
        default="markdown",
        help="Output format (default: markdown)",
    )

    # Content extraction group
    extraction_group = parser.add_argument_group("Content Extraction")
    extraction_group.add_argument(
        "--content-selector",
        metavar="SELECTOR",
        help="CSS selector for main content area",
    )
    extraction_group.add_argument(
        "--ignore-selectors",
        nargs="+",
        metavar="SELECTOR",
        help="CSS selectors to ignore (nav, header, footer, etc.)",
    )
    extraction_group.add_argument(
        "--extractor",
        type=Path,
        metavar="FILE",
        help="Path to custom extractor Python file",
    )

    # Processing options group
    processing_group = parser.add_argument_group("Processing Options")
    processing_group.add_argument(
        "--heading-offset",
        type=int,
        default=0,
        metavar="N",
        help="Offset heading levels by N (default: 0)",
    )
    processing_group.add_argument(
        "--no-frontmatter",
        action="store_true",
        help="Don't add YAML frontmatter to output",
    )
    processing_group.add_argument(
        "--parallel",
        action="store_true",
        help="Enable parallel processing for multiple files",
    )

    # Claude AI options group
    ai_group = parser.add_argument_group("Claude AI Options")
    ai_group.add_argument(
        "--claude",
        action="store_true",
        help="Use Claude AI for intelligent HTML to Markdown conversion",
    )
    ai_group.add_argument(
        "--model",
        choices=["opus", "sonnet"],
        default="sonnet",
        help="Claude model to use (default: sonnet)",
    )
    ai_group.add_argument(
        "--sleep",
        type=float,
        default=1.0,
        metavar="SECONDS",
        help="Delay between Claude API calls (default: 1.0)",
    )


def add_analyze_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for analyze command."""
    parser.add_argument(
        "paths",
        nargs="+",
        type=Path,
        help="HTML files or directories to analyze",
    )

    # Analysis options group
    analysis_group = parser.add_argument_group("Analysis Options")
    analysis_group.add_argument(
        "--show-structure",
        action="store_true",
        help="Show detailed HTML structure analysis",
    )
    analysis_group.add_argument(
        "--common-patterns",
        action="store_true",
        help="Find common patterns across multiple files",
    )
    analysis_group.add_argument(
        "--suggest-selectors",
        action="store_true",
        help="Suggest CSS selectors for content extraction",
    )

    # Claude AI options group
    ai_group = parser.add_argument_group("Claude AI Options")
    ai_group.add_argument(
        "--claude",
        action="store_true",
        help="Use Claude AI for intelligent analysis and selector suggestions",
    )
    ai_group.add_argument(
        "--analyze-files",
        type=int,
        default=5,
        metavar="N",
        help="Number of files to analyze with Claude (1-20, default: 5)",
    )
    ai_group.add_argument(
        "--parallel-workers",
        type=int,
        default=5,
        metavar="N",
        help="Number of parallel Claude sessions (1-10, default: 5)",
    )
    ai_group.add_argument(
        "--project-description",
        type=str,
        default="",
        metavar="TEXT",
        help="Project description for Claude context",
    )


def add_config_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for config command."""
    # Configuration options group
    config_group = parser.add_argument_group("Configuration Options")
    config_group.add_argument(
        "-o",
        "--output",
        type=Path,
        default=Path("config.yaml"),
        help="Output configuration file (default: config.yaml)",
    )
    config_group.add_argument(
        "--format",
        choices=["yaml", "toml", "json"],
        default="yaml",
        help="Configuration file format (default: yaml)",
    )


def handle_convert(args: argparse.Namespace) -> None:
    """Handle convert command."""
    # If --claude flag is set, use Claude for conversion
    if args.claude:
        _handle_claude_convert(args)
        return

    # Load configuration
    from html2md_tool.config import Config

    if args.config:
        from html2md_tool.config import load_config
        import yaml

        # Load the config file to check its contents
        with safe_open(args.config, "r") as f:
            config_data = yaml.safe_load(f)

        # If the config only contains extractor settings (from Claude analysis),
        # create a full config with source and destination from CLI
        if "source" not in config_data and "destination" not in config_data:
            source_path = (
                args.source.parent if safe_is_file(args.source) else args.source
            )
            config = Config(source=source_path, destination=args.output)

            # Apply extractor settings from the config file
            if "extractor" in config_data:
                for key, value in config_data["extractor"].items():
                    if hasattr(config.extractor, key):
                        setattr(config.extractor, key, value)

            # Apply conversion settings from the config file
            if "conversion" in config_data:
                for key, value in config_data["conversion"].items():
                    if hasattr(config.conversion, key):
                        setattr(config.conversion, key, value)
        else:
            # Full config file - load it normally
            config = load_config(args.config)

            # IMPORTANT: CLI arguments should always override config file values
            # Only override if CLI args were explicitly provided
            cli_source_path = (
                args.source.parent if safe_is_file(args.source) else args.source
            )
            config.source = cli_source_path
            config.destination = args.output
    else:
        # When source is a file, use its parent directory as the source
        source_path = args.source.parent if safe_is_file(args.source) else args.source
        config = Config(source=source_path, destination=args.output)

    # Update config with CLI arguments
    if args.content_selector:
        config.conversion.outermost_selector = args.content_selector

    if args.ignore_selectors:
        config.conversion.ignore_selectors = args.ignore_selectors

    if args.heading_offset:
        config.processor.heading_offset = args.heading_offset

    if args.no_frontmatter:
        config.conversion.generate_frontmatter = False
        config.conversion.add_frontmatter = False

    if args.parallel:
        config.parallel = True

    if hasattr(args, "format"):
        config.output_format = OutputFormat(args.format)

    config.verbose = args.verbose
    config.quiet = args.quiet
    config.log_file = args.log_file

    # Create converter
    extractor = args.extractor if hasattr(args, "extractor") else None
    converter = Html2mdConverter(config, extractor=extractor)

    # Convert based on source type
    if safe_is_file(args.source):
        info(f"Converting file: {args.source}")
        output = converter.convert_file(args.source)
        success(f"Converted to: {output}")

    elif safe_is_dir(args.source):
        info(f"Converting directory: {args.source}")
        outputs = converter.convert_directory()
        success(f"Converted {len(outputs)} files")

    else:
        error(f"Source not found: {args.source}")
        sys.exit(1)


def handle_analyze(args: argparse.Namespace) -> None:
    """Handle analyze command."""
    from bs4 import BeautifulSoup
    from collections import Counter
    import json

    # Collect all HTML files from provided paths
    html_files = []
    for path in args.paths:
        if not safe_exists(path):
            error(f"Path not found: {path}")
            continue

        if safe_is_file(path):
            # Single file
            if path.suffix.lower() in [".html", ".htm"]:
                html_files.append(path)
            else:
                warning(f"Skipping non-HTML file: {path}")
        elif safe_is_dir(path):
            # Directory - find all HTML files recursively
            found_files = list(path.rglob("*.html")) + list(path.rglob("*.htm"))
            if found_files:
                html_files.extend(found_files)
                info(
                    f"{Colors.BLUE}Found {len(found_files)} HTML files in {path}{Colors.RESET}"
                )
            else:
                warning(f"No HTML files found in {path}")

    if not html_files:
        error("No HTML files to analyze")
        sys.exit(1)

    # If --claude flag is set, use Claude AI for analysis
    if args.claude:
        info(f"\nFound {len(html_files)} HTML files total")
        _handle_claude_analysis(
            html_files,
            args.analyze_files,
            args.parallel_workers,
            args.project_description,
        )
        return

    # Otherwise, do local analysis
    info(f"\nAnalyzing {len(html_files)} HTML files...")

    # Read and parse all files
    parsed_files = []
    for file_path in html_files:
        try:
            content = safe_read_text(file_path, encoding="utf-8")
            soup = BeautifulSoup(content, "html.parser")
            parsed_files.append((file_path, soup))
            # Show relative path from current directory for better identification
            try:
                relative_path = file_path.relative_to(Path.cwd())
            except ValueError:
                relative_path = file_path
            success(f"Parsed: {relative_path}")
        except Exception as e:
            error(f"Error parsing {file_path}: {e}")

    if not parsed_files:
        error("No files could be parsed")
        sys.exit(1)

    # Analyze structure
    if args.show_structure:
        header("HTML Structure Analysis:")
        for file_path, soup in parsed_files:
            info(f"\n{Colors.BLUE}{file_path.name}:{Colors.RESET}")
            _show_structure(soup)

    # Find common patterns
    if args.common_patterns:
        header("Common Patterns:")
        _find_common_patterns(parsed_files)

    # Suggest selectors
    if args.suggest_selectors or (not args.show_structure and not args.common_patterns):
        header("Suggested CSS Selectors:")
        suggestions = _suggest_selectors(parsed_files)

        info(f"\n{Colors.YELLOW}Content selectors:{Colors.RESET}")
        for selector, confidence in suggestions["content"]:
            info(f"  {selector} (confidence: {confidence:.0%})")

        info(f"\n{Colors.YELLOW}Elements to ignore:{Colors.RESET}")
        for selector in suggestions["ignore"]:
            info(f"  {selector}")

        # Print example configuration
        header("Example configuration:")
        info("```yaml")
        info("extractor:")
        if suggestions["content"]:
            info(f"  outermost_selector: \"{suggestions['content'][0][0]}\"")
        info("  ignore_selectors:")
        for selector in suggestions["ignore"]:
            info(f'    - "{selector}"')
        info("```")


def _show_structure(soup):
    """Show the structure of an HTML document."""
    # Find main content areas
    main_areas = soup.find_all(["main", "article", "section", "div"], limit=10)

    for area in main_areas:
        # Get identifying attributes
        attrs = []
        if area.get("id"):
            attrs.append(f"id=\"{area.get('id')}\"")
        if area.get("class"):
            classes = " ".join(area.get("class"))
            attrs.append(f'class="{classes}"')

        attr_str = " ".join(attrs) if attrs else ""
        info(f"  <{area.name} {attr_str}>")

        # Show child elements
        for child in area.find_all(recursive=False, limit=5):
            if child.name:
                child_attrs = []
                if child.get("id"):
                    child_attrs.append(f"id=\"{child.get('id')}\"")
                if child.get("class"):
                    child_classes = " ".join(child.get("class"))
                    child_attrs.append(f'class="{child_classes}"')
                child_attr_str = " ".join(child_attrs) if child_attrs else ""
                info(f"    <{child.name} {child_attr_str}>")


def _find_common_patterns(parsed_files):
    """Find common patterns across HTML files."""
    # Collect all class names and IDs
    all_classes = Counter()
    all_ids = Counter()
    tag_patterns = Counter()

    for _, soup in parsed_files:
        # Count classes
        for elem in soup.find_all(class_=True):
            for cls in elem.get("class", []):
                all_classes[cls] += 1

        # Count IDs
        for elem in soup.find_all(id=True):
            all_ids[elem.get("id")] += 1

        # Count tag patterns
        for elem in soup.find_all(
            ["main", "article", "section", "header", "footer", "nav", "aside"]
        ):
            tag_patterns[elem.name] += 1

    # Show most common patterns
    info(f"\n{Colors.YELLOW}Most common classes:{Colors.RESET}")
    for cls, count in all_classes.most_common(10):
        info(f"  .{cls} (found {count} times)")

    info(f"\n{Colors.YELLOW}Most common IDs:{Colors.RESET}")
    for id_name, count in all_ids.most_common(10):
        info(f"  #{id_name} (found {count} times)")

    info(f"\n{Colors.YELLOW}Common structural elements:{Colors.RESET}")
    for tag, count in tag_patterns.most_common():
        info(f"  <{tag}> (found {count} times)")


def _handle_claude_analysis(
    html_files, num_files_to_analyze=5, parallel_workers=5, project_description=""
):
    """Handle analysis using Claude AI with improved timeout handling and parallel processing."""
    import subprocess
    import os
    import tempfile
    import time
    from pathlib import Path
    import sys

    # Import validate_path_traversal
    from m1f.utils import validate_path_traversal

    # Try to use improved runner if available
    try:
        from html2md_tool.cli_claude import handle_claude_analysis_improved

        return handle_claude_analysis_improved(
            html_files, num_files_to_analyze, parallel_workers, project_description
        )
    except ImportError as e:
        # Print the actual error for debugging
        error(f"Error: {e}")
        pass

    header("Using Claude AI for intelligent analysis...")

    # Find the common parent directory of all HTML files
    if not html_files:
        error("No HTML files to analyze")
        return

    common_parent = Path(os.path.commonpath([str(f.absolute()) for f in html_files]))
    info(f"Analysis directory: {common_parent}")
    info(f"Total HTML files found: {len(html_files)}")

    # Check if we have enough files
    if len(html_files) == 0:
        error("No HTML files found in the specified directory")
        return

    # We'll work from the current directory and use --add-dir for Claude
    original_dir = Path.cwd()

    # Step 1: Create m1f and analysis directories if they don't exist
    m1f_dir = common_parent / "m1f"
    safe_mkdir(m1f_dir, exist_ok=True)
    analysis_dir = m1f_dir / "analysis"
    safe_mkdir(analysis_dir, exist_ok=True)

    # Clean old analysis files
    for old_file in analysis_dir.glob("*.txt"):
        if old_file.name != "log.txt":
            old_file.unlink()

    # Initialize analysis log
    from datetime import datetime

    log_file = analysis_dir / "log.txt"
    log_file.write_text(f"Analysis started: {datetime.now().isoformat()}\n")

    # Create a filelist with all HTML files using m1f
    info("\n🔧 Creating HTML file list using m1f...")
    info(f"Working with HTML directory: {common_parent}")

    # Run m1f to create only the filelist (not the content)
    m1f_cmd = [
        "m1f",
        "-s",
        str(common_parent),
        "-o",
        str(m1f_dir / "all_html_files.txt"),
        "--include-extensions",
        ".html",
        ".htm",
        "--skip-output-file",  # This creates only the filelist, not the content
        "--force",
    ]

    try:
        result = subprocess.run(m1f_cmd, capture_output=True, text=True, check=True)

        # Find the generated filelist (m1f creates *_filelist.txt)
        filelist_files = list(m1f_dir.glob("*_filelist.txt"))
        if not filelist_files:
            error("m1f filelist not created")
            return
        # Use the most recent filelist if multiple exist
        html_filelist = max(filelist_files, key=lambda p: p.stat().st_mtime)
        if not safe_exists(html_filelist):
            error("m1f filelist not created")
            return

        success(f"Created HTML file list: {html_filelist}")

    except subprocess.CalledProcessError as e:
        error(f"Failed to create HTML file list: {e.stderr}")
        return

    # Get relative paths from the common parent (still needed for filtering)
    relative_paths = []
    for f in html_files:
        try:
            rel_path = f.relative_to(common_parent)
            relative_paths.append(str(rel_path))
        except ValueError:
            relative_paths.append(str(f))

    # Step 1: Load the file selection prompt
    prompt_dir = Path(__file__).parent / "prompts"
    select_prompt_path = prompt_dir / "select_files_from_project.md"

    if not safe_exists(select_prompt_path):
        error(f"Prompt file not found: {select_prompt_path}")
        return

    # Load the prompt from external file
    simple_prompt_template = safe_read_text(select_prompt_path)

    # Validate and adjust number of files to analyze
    if num_files_to_analyze < 1:
        num_files_to_analyze = 1
        warning("Minimum is 1 file. Using 1.")
    elif num_files_to_analyze > 20:
        num_files_to_analyze = 20
        warning("Maximum is 20 files. Using 20.")

    if num_files_to_analyze > len(html_files):
        num_files_to_analyze = len(html_files)
        warning(f"Only {len(html_files)} files available. Will analyze all of them.")

    # Ask user for project description if not provided
    if not project_description:
        header("Project Context:")
        info(
            "Please briefly describe what this HTML project contains so Claude can better understand"
        )
        info(
            "what should be converted to Markdown. Example: 'Documentation for XY software - API section'"
        )
        info(
            "\nTip: If there are particularly important files to analyze, mention them in your description"
        )
        info("     so Claude will prioritize those files in the analysis.")
        project_description = input("\nProject description: ").strip()
    else:
        header(f"Project Context: {project_description}")

    # Update the prompt with the number of files
    simple_prompt_template = simple_prompt_template.replace(
        "5 representative", f"{num_files_to_analyze} representative"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "select 5", f"select {num_files_to_analyze}"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "EXACTLY 5 file paths", f"EXACTLY {num_files_to_analyze} file paths"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "exactly 5 representative", f"exactly {num_files_to_analyze} representative"
    )

    # Add project description to the prompt
    if project_description:
        simple_prompt = (
            f"PROJECT CONTEXT: {project_description}\n\n{simple_prompt_template}"
        )
    else:
        simple_prompt = simple_prompt_template

    info(f"\nAsking Claude to select {num_files_to_analyze} representative files...")

    try:
        # Run claude using the same approach as m1f-claude
        cmd = [
            "claude",
            "--print",  # Use --print instead of -p
            "--allowedTools",
            "Read,Glob,Grep,Write",  # Allow file reading and writing tools
            "--add-dir",
            str(common_parent),  # Give Claude access to the HTML directory
        ]

        # Use subprocess.run() which works more reliably with Claude
        result = subprocess.run(
            cmd,
            input=simple_prompt,
            capture_output=True,
            text=True,
            timeout=180,  # 3 minutes for file selection
        )

        if result.returncode != 0:
            raise subprocess.CalledProcessError(
                result.returncode, cmd, output=result.stdout, stderr=result.stderr
            )
        selected_files = result.stdout.strip().split("\n")
        selected_files = [f.strip() for f in selected_files if f.strip()]

        # Filter out any lines that are not file paths (e.g., explanations)
        valid_files = []
        for f in selected_files:
            # Skip lines that look like explanations (contain "select" or start with lowercase or are too long)
            if (
                any(
                    word in f.lower()
                    for word in ["select", "based on", "analysis", "representative"]
                )
                or len(f) > 100
            ):
                continue
            # Only keep lines that look like file paths (contain .html or /)
            if ".html" in f or "/" in f:
                valid_files.append(f)

        selected_files = valid_files

        info(f"\nClaude selected {len(selected_files)} files:")
        for f in selected_files:
            info(f"  - {Colors.BLUE}{f}{Colors.RESET}")

    except subprocess.TimeoutExpired:
        warning("Timeout selecting files (3 minutes)")
        return
    except subprocess.CalledProcessError as e:
        error(f"Claude command failed: {e}")
        error(f"Error output: {e.stderr}")
        return
    except FileNotFoundError:
        # Try to find claude in common locations
        claude_paths = [
            Path.home() / ".claude" / "local" / "claude",
            Path("/usr/local/bin/claude"),
            Path("/usr/bin/claude"),
        ]

        claude_found = False
        for claude_path in claude_paths:
            if safe_exists(claude_path) and safe_is_file(claude_path):
                warning(f"Found claude at: {claude_path}")
                # Update the command to use the full path
                cmd[0] = str(claude_path)
                try:
                    result = subprocess.run(
                        cmd,
                        input=simple_prompt,
                        capture_output=True,
                        text=True,
                        timeout=180,
                    )

                    if result.returncode != 0:
                        raise subprocess.CalledProcessError(
                            result.returncode,
                            cmd,
                            output=result.stdout,
                            stderr=result.stderr,
                        )

                    selected_files = result.stdout.strip().split("\n")
                    selected_files = [f.strip() for f in selected_files if f.strip()]

                    # Filter out any lines that are not file paths (e.g., explanations)
                    valid_files = []
                    for f in selected_files:
                        if (
                            any(
                                word in f.lower()
                                for word in [
                                    "select",
                                    "based on",
                                    "analysis",
                                    "representative",
                                ]
                            )
                            or len(f) > 100
                        ):
                            continue
                        if ".html" in f or "/" in f:
                            valid_files.append(f)

                    selected_files = valid_files

                    info(f"\nClaude selected {len(selected_files)} files:")
                    for f in selected_files:
                        info(f"  - {Colors.BLUE}{f}{Colors.RESET}")

                    claude_found = True
                    break

                except Exception as e:
                    warning(f"Failed with {claude_path}: {e}")
                    continue

        if not claude_found:
            error("claude command not found. Please install Claude CLI.")
            warning(
                "If claude is installed as an alias, try adding it to your PATH or creating a symlink."
            )
            return

    # Step 2: Verify the selected files exist and save to file
    info("\nVerifying selected HTML files...")
    verified_files = []

    for file_path in selected_files[:num_files_to_analyze]:  # Limit to selected number
        file_path = file_path.strip()

        # Check if file exists (relative to common_parent)
        full_path = common_parent / file_path
        if safe_exists(full_path):
            verified_files.append(file_path)
            success(f"Found: {file_path}")
        else:
            warning(f"Not found: {file_path}")

    if not verified_files:
        error("No HTML files could be verified")
        return

    # Write the verified files to a reference list
    selected_files_path = m1f_dir / "selected_html_files.txt"
    with safe_open(selected_files_path, "w") as f:
        for file_path in verified_files:
            f.write(f"{file_path}\n")
    success(f"Wrote selected files list to: {selected_files_path}")

    # Step 3: Analyze each file individually with Claude
    info("\nAnalyzing each file individually with Claude...")

    # Load the individual analysis prompt template
    individual_prompt_path = prompt_dir / "analyze_individual_file.md"

    if not safe_exists(individual_prompt_path):
        error(f"Prompt file not found: {individual_prompt_path}")
        return

    individual_prompt_template = safe_read_text(individual_prompt_path)

    # Analyze each of the selected files
    for i, file_path in enumerate(verified_files, 1):
        info(f"\n📋 Analyzing file {i}/{len(verified_files)}: {file_path}")
        info(f"⏱️  Starting analysis at {time.strftime('%H:%M:%S')}")

        # Customize prompt for this specific file
        individual_prompt = individual_prompt_template.replace("{filename}", file_path)
        individual_prompt = individual_prompt.replace("{file_number}", str(i))

        # Add project context if provided
        if project_description:
            individual_prompt = (
                f"PROJECT CONTEXT: {project_description}\n\n{individual_prompt}"
            )

        try:
            # Run claude for this individual file
            # First try with 'claude' command, then fall back to known paths
            claude_cmd = "claude"
            claude_paths = [
                Path.home() / ".claude" / "local" / "claude",
                Path("/usr/local/bin/claude"),
                Path("/usr/bin/claude"),
            ]

            # Check if we need to use full path
            try:
                subprocess.run(["claude", "--version"], capture_output=True, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # Try to find claude in known locations
                for path in claude_paths:
                    if safe_exists(path) and safe_is_file(path):
                        claude_cmd = str(path)
                        break

            cmd = [
                claude_cmd,
                "--print",
                "--allowedTools",
                "Read,Glob,Grep,Write",
                "--add-dir",
                str(common_parent),
            ]

            # Use subprocess.run() which works more reliably with Claude
            result = subprocess.run(
                cmd,
                input=individual_prompt,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minutes per file analysis
            )

            # Debug: Show process details
            info(f"🔍 Process return code: {result.returncode}")
            if result.stderr:
                info(f"🔍 stderr: {result.stderr[:200]}...")

            if result.returncode != 0:
                error(f"Analysis failed for {file_path}: {result.stderr}")
                continue

            # Show Claude's response for transparency
            if result.stdout.strip():
                info(f"📄 Claude: {result.stdout.strip()}")

            success(f"Analysis completed for file {i}")

        except subprocess.TimeoutExpired:
            warning(f"Timeout analyzing {file_path} (5 minutes)")
            continue
        except Exception as e:
            error(f"Error analyzing {file_path}: {e}")
            continue

    # Step 4: Synthesize all analyses into final config
    info("\n🔬 Synthesizing analyses into final configuration...")

    # Load the synthesis prompt
    synthesis_prompt_path = prompt_dir / "synthesize_config.md"

    if not safe_exists(synthesis_prompt_path):
        error(f"Prompt file not found: {synthesis_prompt_path}")
        return

    synthesis_prompt = safe_read_text(synthesis_prompt_path)

    # Update the synthesis prompt with the actual number of files analyzed
    synthesis_prompt = synthesis_prompt.replace(
        "analyzed 5 HTML files", f"analyzed {len(verified_files)} HTML files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "You have analyzed 5 HTML files",
        f"You have analyzed {len(verified_files)} HTML files",
    )

    # Build the file list dynamically
    file_list = []
    for i in range(1, len(verified_files) + 1):
        file_list.append(f"- m1f/analysis/html_analysis_{i}.txt")

    # Replace the static file list with the dynamic one
    old_file_list = """Read the 5 analysis files:
- m1f/analysis/html_analysis_1.txt
- m1f/analysis/html_analysis_2.txt  
- m1f/analysis/html_analysis_3.txt
- m1f/analysis/html_analysis_4.txt
- m1f/analysis/html_analysis_5.txt"""

    new_file_list = f"Read the {len(verified_files)} analysis files:\n" + "\n".join(
        file_list
    )
    synthesis_prompt = synthesis_prompt.replace(old_file_list, new_file_list)

    # Update other references to "5 files"
    synthesis_prompt = synthesis_prompt.replace(
        "Analyzed 5 files", f"Analyzed {len(verified_files)} files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "works on X/5 files", f"works on X/{len(verified_files)} files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "found in X/5 files", f"found in X/{len(verified_files)} files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "(4-5 out of 5)",
        f"({len(verified_files)-1}-{len(verified_files)} out of {len(verified_files)})",
    )
    synthesis_prompt = synthesis_prompt.replace(
        "works on 4/5 files",
        f"works on {max(1, len(verified_files)-1)}/{len(verified_files)} files",
    )
    synthesis_prompt = synthesis_prompt.replace(
        "works on 3/5 files",
        f"works on {max(1, len(verified_files)//2)}/{len(verified_files)} files",
    )
    synthesis_prompt = synthesis_prompt.replace(
        "found in 3+ files", f"found in {max(2, len(verified_files)//2)}+ files"
    )

    # Add project context if provided
    if project_description:
        synthesis_prompt = (
            f"PROJECT CONTEXT: {project_description}\n\n{synthesis_prompt}"
        )

    try:
        # Run claude for synthesis
        # Use the same claude command detection as before
        claude_cmd = "claude"
        claude_paths = [
            Path.home() / ".claude" / "local" / "claude",
            Path("/usr/local/bin/claude"),
            Path("/usr/bin/claude"),
        ]

        # Check if we need to use full path
        try:
            subprocess.run(["claude", "--version"], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            # Try to find claude in known locations
            for path in claude_paths:
                if safe_exists(path) and safe_is_file(path):
                    claude_cmd = str(path)
                    break

        cmd = [
            claude_cmd,
            "--print",
            "--allowedTools",
            "Read,Glob,Grep,Write",
            "--add-dir",
            str(common_parent),
        ]

        # Use subprocess.run() which works more reliably with Claude
        result = subprocess.run(
            cmd,
            input=synthesis_prompt,
            capture_output=True,
            text=True,
            timeout=300,  # 5 minutes for synthesis
        )

        if result.returncode != 0:
            raise subprocess.CalledProcessError(
                result.returncode, cmd, output=result.stdout, stderr=result.stderr
            )

        header("Claude's Final Configuration:")
        info(result.stdout)

        # Try to parse the YAML config from Claude's output
        import yaml

        try:
            # Extract YAML from the output (between ```yaml and ```)
            output = result.stdout
            yaml_start = output.find("```yaml")
            yaml_end = output.find("```", yaml_start + 6)

            if yaml_start != -1 and yaml_end != -1:
                yaml_content = output[yaml_start + 7 : yaml_end].strip()
                config_data = yaml.safe_load(yaml_content)

                # Clean up the config - remove empty strings
                if "extractor" in config_data:
                    extractor = config_data["extractor"]
                    if "alternative_selectors" in extractor:
                        extractor["alternative_selectors"] = [
                            s for s in extractor["alternative_selectors"] if s
                        ]
                    if "ignore_selectors" in extractor:
                        extractor["ignore_selectors"] = [
                            s for s in extractor["ignore_selectors"] if s
                        ]

                # Save the config to a file with consistent name
                config_file = common_parent / "html2md_config.yaml"
                with safe_open(config_file, "w") as f:
                    yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

                success(f"Configuration saved to: {config_file}")

                # Show clear usage instructions
                info("\n" + "=" * 60)
                info(
                    f"{Colors.GREEN}{Colors.BOLD}✨ Analysis Complete! Here's how to convert your HTML files:{Colors.RESET}"
                )
                info("=" * 60 + "\n")

                info(
                    f"{Colors.BOLD}Option 1: Use the generated configuration (RECOMMENDED){Colors.RESET}"
                )
                info(
                    "This uses the CSS selectors Claude identified to extract only the main content:\n"
                )
                info(
                    f"{Colors.CYAN}m1f-html2md convert {common_parent} -o ./markdown -c {config_file}{Colors.RESET}\n"
                )

                info(
                    f"{Colors.BOLD}Option 2: Use Claude AI for each file{Colors.RESET}"
                )
                info(
                    "This uses Claude to intelligently extract content from each file individually:"
                )
                info("(Slower but may handle edge cases better)\n")
                info(
                    f"{Colors.CYAN}m1f-html2md convert {common_parent} -o ./markdown --claude{Colors.RESET}\n"
                )

                info(f"{Colors.BOLD}Option 3: Convert a single file{Colors.RESET}")
                info("To test the configuration on a single file first:\n")
                info(
                    f"{Colors.CYAN}m1f-html2md convert path/to/file.html -o test.md -c {config_file}{Colors.RESET}\n"
                )

                info("=" * 60)
            else:
                warning("Could not extract YAML configuration from Claude's response")
                info(
                    "Please manually create html2md_config.yaml based on the analysis above."
                )
                info(
                    "\nExpected format: The YAML should be between ```yaml and ``` markers."
                )

        except Exception as e:
            warning(f"Could not save configuration: {e}")
            info(
                f"Please manually create {common_parent}/html2md_config.yaml based on the analysis above."
            )

    except subprocess.TimeoutExpired:
        warning("Timeout synthesizing configuration (5 minutes)")
    except subprocess.CalledProcessError as e:
        error(f"Claude command failed: {e}")
        error(f"Error output: {e.stderr}")

    # Ask if temporary analysis files should be deleted
    header("Cleanup:")
    cleanup = input("Delete temporary analysis files (html_analysis_*.txt)? [Y/n]: ")

    if cleanup.lower() != "n":
        # Delete analysis files
        deleted_count = 0
        for i in range(1, num_files_to_analyze + 1):
            analysis_file = analysis_dir / f"html_analysis_{i}.txt"
            if safe_exists(analysis_file):
                try:
                    analysis_file.unlink()
                    deleted_count += 1
                except Exception as e:
                    warning(f"Could not delete {analysis_file.name}: {e}")

        if deleted_count > 0:
            success(f"Deleted {deleted_count} temporary analysis files")
    else:
        info(
            f"{Colors.BLUE}ℹ️  Temporary analysis files kept in m1f/ directory{Colors.RESET}"
        )


def _suggest_selectors(parsed_files):
    """Suggest CSS selectors for content extraction."""
    suggestions = {"content": [], "ignore": []}

    # Common content selectors to try
    content_selectors = [
        "main",
        "article",
        "[role='main']",
        "#content",
        "#main",
        ".content",
        ".main-content",
        ".entry-content",
        ".post-content",
        ".page-content",
    ]

    # Common elements to ignore
    ignore_patterns = [
        "nav",
        "header",
        "footer",
        "aside",
        ".sidebar",
        ".navigation",
        ".menu",
        ".header",
        ".footer",
        ".ads",
        ".advertisement",
        ".cookie-notice",
        ".popup",
        ".modal",
        "#comments",
        ".comments",
    ]

    # Test content selectors
    for selector in content_selectors:
        found_count = 0
        total_files = len(parsed_files)

        for _, soup in parsed_files:
            if soup.select(selector):
                found_count += 1

        if found_count > 0:
            confidence = found_count / total_files
            suggestions["content"].append((selector, confidence))

    # Sort by confidence
    suggestions["content"].sort(key=lambda x: x[1], reverse=True)

    # Add ignore selectors that exist
    for _, soup in parsed_files:
        for pattern in ignore_patterns:
            if soup.select(pattern):
                if pattern not in suggestions["ignore"]:
                    suggestions["ignore"].append(pattern)

    return suggestions


def _handle_claude_convert(args: argparse.Namespace) -> None:
    """Handle conversion using Claude AI."""
    import subprocess
    import time
    from pathlib import Path
    import sys

    from m1f.utils import validate_path_traversal

    # Try to use improved converter if available
    try:
        from html2md_tool.convert_claude import handle_claude_convert_improved

        return handle_claude_convert_improved(args)
    except ImportError:
        pass

    header("Using Claude AI to convert HTML to Markdown...")
    info(f"Model: {args.model}")
    info(f"Sleep between calls: {args.sleep} seconds")

    # Find all HTML files in source directory
    source_path = args.source
    if not safe_exists(source_path):
        error(f"Source path not found: {source_path}")
        sys.exit(1)

    html_files = []
    if safe_is_file(source_path):
        if source_path.suffix.lower() in [".html", ".htm"]:
            html_files.append(source_path)
        else:
            error(f"Source file is not HTML: {source_path}")
            sys.exit(1)
    elif safe_is_dir(source_path):
        # Find all HTML files recursively
        html_files = list(source_path.rglob("*.html")) + list(
            source_path.rglob("*.htm")
        )
        info(f"Found {len(html_files)} HTML files in {source_path}")

    if not html_files:
        error("No HTML files found to convert")
        sys.exit(1)

    # Prepare output directory
    output_path = args.output
    if safe_exists(output_path) and safe_is_file(output_path):
        error(f"Output path is a file, expected directory: {output_path}")
        sys.exit(1)

    if not safe_exists(output_path):
        safe_mkdir(output_path, parents=True, exist_ok=True)
        info(f"Created output directory: {output_path}")

    # Load conversion prompt
    prompt_path = Path(__file__).parent / "prompts" / "convert_html_to_md.md"
    if not safe_exists(prompt_path):
        error(f"Prompt file not found: {prompt_path}")
        sys.exit(1)

    prompt_template = safe_read_text(prompt_path)

    # Model parameter for Claude CLI (just use the short names)
    model_param = args.model

    # Process each HTML file
    converted_count = 0
    failed_count = 0

    for i, html_file in enumerate(html_files):
        tmp_html_path = None
        try:
            # Validate path to prevent traversal attacks
            validated_path = validate_path_traversal(
                html_file,
                base_path=(
                    source_path if safe_is_dir(source_path) else source_path.parent
                ),
                allow_outside=False,
            )

            # Read HTML content
            html_content = safe_read_text(validated_path, encoding="utf-8")

            # Determine output file path
            if safe_is_file(source_path):
                # Single file conversion
                output_file = output_path / html_file.with_suffix(".md").name
            else:
                # Directory conversion - maintain structure
                relative_path = html_file.relative_to(source_path)
                output_file = output_path / relative_path.with_suffix(".md")

            # Create output directory if needed
            output_file.parent.mkdir(parents=True, exist_ok=True)

            info(f"\n[{i+1}/{len(html_files)}] Converting: {html_file.name}")

            # Create a temporary file with the HTML content
            import tempfile

            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".html", delete=False, encoding="utf-8"
            ) as tmp_html:
                tmp_html.write(html_content)
                tmp_html_path = tmp_html.name

            # Prepare the prompt for the temporary file
            prompt = prompt_template.replace("{html_content}", f"@{tmp_html_path}")

            # Call Claude with the prompt referencing the file
            # Detect claude command location
            claude_cmd = "claude"
            claude_paths = [
                Path.home() / ".claude" / "local" / "claude",
                Path("/usr/local/bin/claude"),
                Path("/usr/bin/claude"),
            ]

            # Check if we need to use full path
            try:
                subprocess.run(["claude", "--version"], capture_output=True, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # Try to find claude in known locations
                for path in claude_paths:
                    if safe_exists(path) and safe_is_file(path):
                        claude_cmd = str(path)
                        break

            cmd = [claude_cmd, "-p", prompt, "--model", model_param]

            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            # Save the markdown output
            markdown_content = result.stdout.strip()
            output_file.write_text(markdown_content, encoding="utf-8")

            success(f"Converted to: {output_file}")
            converted_count += 1

            # Sleep between API calls (except for the last one)
            if i < len(html_files) - 1 and args.sleep > 0:
                info(f"Sleeping for {args.sleep} seconds...")
                time.sleep(args.sleep)

        except subprocess.CalledProcessError as e:
            error(f"Claude conversion failed: {e}")
            if e.stderr:
                error(f"Error: {e.stderr}")
            failed_count += 1
        except Exception as e:
            error(f"Error processing {html_file}: {e}")
            failed_count += 1
        finally:
            # Clean up temporary file
            if tmp_html_path:
                try:
                    Path(tmp_html_path).unlink()
                except:
                    pass

    # Summary
    header("Conversion Summary:")
    success(f"Successfully converted: {converted_count} files")
    if failed_count > 0:
        error(f"Failed to convert: {failed_count} files")

    if converted_count == 0:
        sys.exit(1)


def handle_config(args: argparse.Namespace) -> None:
    """Handle config command."""
    from html2md_tool.config import Config

    # Create default configuration
    config = Config(source=Path("./html"), destination=Path("./markdown"))

    # Generate config file
    config_dict = config.model_dump()

    if args.format == "yaml":
        import yaml

        content = yaml.dump(config_dict, default_flow_style=False, sort_keys=False)
    elif args.format == "toml":
        import toml

        content = toml.dumps(config_dict)
    elif args.format == "json":
        import json

        content = json.dumps(config_dict, indent=2)
    else:
        error(f"Unsupported format: {args.format}")
        sys.exit(1)

    # Write config file
    args.output.write_text(content, encoding="utf-8")
    success(f"Created configuration file: {args.output}")


def create_simple_parser() -> argparse.ArgumentParser:
    """Create a simple parser for test compatibility."""
    parser = argparse.ArgumentParser(
        prog="m1f-html2md", description="Convert HTML to Markdown"
    )

    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )
    parser.add_argument("--source-dir", type=str, help="Source directory or URL")
    parser.add_argument("--destination-dir", type=Path, help="Destination directory")
    parser.add_argument(
        "--outermost-selector", type=str, help="CSS selector for content"
    )
    parser.add_argument("--ignore-selectors", nargs="+", help="CSS selectors to ignore")
    parser.add_argument("--include-patterns", nargs="+", help="Patterns to include")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    return parser


def main() -> None:
    """Main entry point."""
    # Check if running in simple mode (for tests) - but NOT for --help or --version
    if len(sys.argv) > 1 and sys.argv[1] in ["--source-dir"]:
        parser = create_simple_parser()
        args = parser.parse_args()

        if args.source_dir and args.destination_dir:
            # Simple conversion mode
            from html2md_tool.config import ConversionOptions

            options = ConversionOptions(
                source_dir=args.source_dir,
                destination_dir=args.destination_dir,
                outermost_selector=args.outermost_selector,
                ignore_selectors=args.ignore_selectors,
            )
            converter = Html2mdConverter(options)

            # For URL sources, convert them
            if args.source_dir.startswith("http"):
                info(f"Converting {args.source_dir}")

                # Handle include patterns if specified
                if args.include_patterns:
                    # Convert specific pages
                    import asyncio

                    urls = [
                        f"{args.source_dir}/{pattern}"
                        for pattern in args.include_patterns
                    ]
                    results = asyncio.run(converter.convert_directory_from_urls(urls))
                    info(f"Converted {len(results)} pages")
                else:
                    # Convert single URL
                    output_path = converter.convert_url(args.source_dir)
                    info(f"Converted to {output_path}")

                success("Conversion completed successfully")
            sys.exit(0)
        sys.exit(0)

    # Regular mode with subcommands
    parser = create_parser()
    args = parser.parse_args()

    # Handle no command
    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Configure console
    if args.quiet:
        # console.quiet - removed
        pass

    # Dispatch to command handlers
    try:
        if args.command == "convert":
            handle_convert(args)
        elif args.command == "analyze":
            handle_analyze(args)
        elif args.command == "config":
            handle_config(args)
        else:
            error(f"Unknown command: {args.command}")
            sys.exit(1)

    except KeyboardInterrupt:
        warning("Interrupted by user")
        sys.exit(1)
    except Exception as e:
        error(f"Error: {e}")
        if args.verbose:
            import traceback

            info(traceback.format_exc())
        sys.exit(1)


if __name__ == "__main__":
    main()

======= html2md_tool/cli_claude.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Improved Claude analysis functions for HTML to Markdown converter."""

import os
import subprocess
import time
from pathlib import Path
from typing import List
from datetime import datetime

from shared.colors import info, error, warning, success, header, Colors
from html2md_tool.claude_runner import ClaudeRunner
from m1f.file_operations import safe_exists, safe_mkdir, safe_open, safe_read_text


def handle_claude_analysis_improved(
    html_files: List[Path],
    num_files_to_analyze: int = 5,
    parallel_workers: int = 5,
    project_description: str = "",
):
    """Handle analysis using Claude AI with improved timeout handling and parallel processing."""

    header("\nUsing Claude AI for intelligent analysis...")
    warning("⏱️  Note: Processing large HTML files (2MB+) may take several minutes.")

    # Find the common parent directory of all HTML files
    if not html_files:
        error("❌ No HTML files to analyze")
        return

    common_parent = Path(os.path.commonpath([str(f.absolute()) for f in html_files]))
    info(f"📁 Analysis directory: {common_parent}")
    info(f"📊 Total HTML files found: {len(html_files)}")

    # Initialize Claude runner
    try:
        runner = ClaudeRunner(
            max_workers=parallel_workers, working_dir=str(common_parent)
        )
    except Exception as e:
        error(f"❌ {e}")
        return

    # Check if we have enough files
    if len(html_files) == 0:
        error("❌ No HTML files found in the specified directory")
        return

    # Step 1: Create m1f and analysis directories if they don't exist
    m1f_dir = common_parent / "m1f"
    m1f_dir.mkdir(exist_ok=True)
    analysis_dir = m1f_dir / "analysis"
    analysis_dir.mkdir(exist_ok=True)

    # Clean old analysis files
    for old_file in analysis_dir.glob("*.txt"):
        if old_file.name != "log.txt":
            old_file.unlink()

    # Initialize analysis log
    log_file = analysis_dir / "log.txt"
    log_file.write_text(f"Analysis started: {datetime.now().isoformat()}\n")

    # Ask user for project description FIRST, before m1f runs
    if not project_description:
        header("\nProject Context:")
        info(
            "Please briefly describe what this HTML project contains so Claude can better understand"
        )
        info(
            "what should be converted to Markdown. Example: 'Documentation for XY software - API section'"
        )
        info(
            f"\n{Colors.DIM}Tip: If there are particularly important files to analyze, mention them in your description{Colors.RESET}"
        )
        info(
            f"{Colors.DIM}     so Claude will prioritize those files in the analysis.{Colors.RESET}"
        )
        project_description = input("\nProject description: ").strip()
    else:
        info(f"\n📋 {Colors.BOLD}Project Context:{Colors.RESET} {project_description}")

    # Create a filelist with all HTML files using m1f
    info("\n🔧 Creating HTML file list using m1f (only filelist, not content)...")
    info(f"Working with HTML directory: {common_parent}")

    # Run m1f to create only the filelist (not the content)
    # Run from the target directory to avoid path traversal issues
    m1f_cmd = [
        "m1f",
        "-s",
        ".",  # Use current directory
        "-o",
        str(m1f_dir / "all_html_files"),  # Base name - m1f will add _filelist.txt
        "--include-extensions",
        ".html",
        ".htm",
        "--include-dot-paths",  # Include hidden paths
        "--skip-output-file",  # ONLY create filelist, not the content file
    ]

    try:
        # Run m1f from the common_parent directory
        # Add tools directory to PYTHONPATH to ensure m1f can be imported
        env = os.environ.copy()
        m1f_tools_path = Path(__file__).parent.parent  # Path to tools directory
        if "PYTHONPATH" in env:
            env["PYTHONPATH"] = f"{m1f_tools_path}:{env['PYTHONPATH']}"
        else:
            env["PYTHONPATH"] = str(m1f_tools_path)

        info(f"   {Colors.DIM}Running: {' '.join(m1f_cmd[:5])}...{Colors.RESET}")

        # Don't capture output - let m1f show its own progress
        result = subprocess.run(
            m1f_cmd,
            check=True,
            timeout=300,  # 5 minutes for large projects
            cwd=str(common_parent),  # Change working directory for m1f
            env=env,  # Use modified environment with PYTHONPATH
        )
        success("✅ Created HTML file list")
    except subprocess.CalledProcessError as e:
        error(f"❌ Failed to create file list: {e}")
        error(f"   m1f exit code: {e.returncode}")
        return
    except subprocess.TimeoutExpired:
        error("❌ Timeout creating file list after 5 minutes")
        error("   For very large projects, consider using a more specific path")
        error("   or reducing the scope with --exclude patterns")
        return

    # Define path to the file list that was just created
    # m1f creates filename_filelist.txt when using --skip-output-file
    file_list_path = m1f_dir / "all_html_files_filelist.txt"

    # Get relative paths for all HTML files
    relative_paths = []
    for f in html_files:
        try:
            rel_path = f.relative_to(common_parent)
            relative_paths.append(str(rel_path))
        except ValueError:
            relative_paths.append(str(f))

    # Step 2: Load the file selection prompt
    prompt_dir = Path(__file__).parent / "prompts"
    select_prompt_path = prompt_dir / "select_files_from_project.md"

    if not safe_exists(select_prompt_path):
        error(f"❌ Prompt file not found: {select_prompt_path}")
        return

    # Load the prompt from external file
    simple_prompt_template = safe_read_text(select_prompt_path)

    # Validate and adjust number of files to analyze
    if num_files_to_analyze < 1:
        num_files_to_analyze = 1
        warning("Minimum is 1 file. Using 1.")
    elif num_files_to_analyze > 20:
        num_files_to_analyze = 20
        warning("Maximum is 20 files. Using 20.")

    if num_files_to_analyze > len(html_files):
        num_files_to_analyze = len(html_files)
        warning(f"Only {len(html_files)} files available. Will analyze all of them.")

    # Project description was already collected earlier

    # Update the prompt with the number of files
    simple_prompt_template = simple_prompt_template.replace(
        "5 representative", f"{num_files_to_analyze} representative"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "select 5", f"select {num_files_to_analyze}"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "EXACTLY 5 file paths", f"EXACTLY {num_files_to_analyze} file paths"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "exactly 5 representative", f"exactly {num_files_to_analyze} representative"
    )
    simple_prompt_template = simple_prompt_template.replace(
        "exactly 5 files", f"exactly {num_files_to_analyze} files"
    )

    # The file list is already saved in all_html_files_filelist.txt
    # Use absolute path so Claude can read it directly
    simple_prompt = f"""Available HTML files are listed in: {str(file_list_path)}

{simple_prompt_template}"""

    # Add project context if provided
    if project_description:
        simple_prompt = f"PROJECT CONTEXT: {project_description}\n\n{simple_prompt}"

    info(f"\n🤔 Asking Claude to select {num_files_to_analyze} representative files...")
    info(f"   {Colors.DIM}This may take 10-30 seconds...{Colors.RESET}")

    # Step 3: Use Claude to select representative files
    returncode, stdout, stderr = runner.run_claude_streaming_json(
        prompt=simple_prompt,
        allowed_tools="Read,Task,TodoWrite",  # Allow Read for file access, Task for sub-agents, TodoWrite for task management
        add_dir=str(common_parent),  # Set working directory for file resolution
        timeout=180,  # 3 minutes for file selection
        working_dir=str(common_parent),
        show_progress=True,  # Show progress for file selection too
    )

    if returncode != 0:
        error(f"❌ Claude command failed: {stderr}")
        return

    # Check if Claude returned output
    if not stdout.strip():
        warning("⚠️  Claude returned empty output")
        if stderr:
            warning(f"Error details: {stderr[:500]}")

    # Parse JSON output to extract Claude's actual text responses
    import json

    claude_text_output = []

    for line in stdout.strip().split("\n"):
        if not line.strip():
            continue
        try:
            json_obj = json.loads(line)
            # Extract text from assistant messages
            if json_obj.get("type") == "assistant":
                message = json_obj.get("message", {})
                if isinstance(message, dict):
                    content_parts = message.get("content", [])
                    if isinstance(content_parts, list):
                        for part in content_parts:
                            if isinstance(part, dict) and part.get("type") == "text":
                                text = part.get("text", "")
                                if text:
                                    claude_text_output.append(text)
        except json.JSONDecodeError:
            # If it's not JSON, it might be plain text (backwards compatibility)
            claude_text_output.append(line)

    # Join all text outputs and split by newlines to get individual lines
    full_text = "\n".join(claude_text_output)

    selected_files = full_text.strip().split("\n")
    selected_files = [f.strip() for f in selected_files if f.strip()]

    # Filter out any lines that are not file paths
    valid_files = []
    for line in selected_files:
        line = line.strip()

        # Skip empty lines and the completion marker
        if not line or "FILE_SELECTION_COMPLETE_OK" in line:
            continue

        # Skip lines that look like explanatory text
        if any(
            word in line.lower()
            for word in [
                "select",
                "based",
                "analysis",
                "representative",
                "file:",
                "path:",
            ]
        ):
            continue

        # Skip lines that are too long to be reasonable file paths
        if len(line) > 300:
            continue

        # Accept lines that look like HTML file paths
        if ".html" in line.lower() or ".htm" in line.lower():
            # Clean up the path - remove any leading/trailing whitespace or quotes
            clean_path = line.strip().strip('"').strip("'")

            # If the path is in our relative_paths list, it's definitely valid
            if clean_path in relative_paths:
                valid_files.append(clean_path)
            else:
                # Otherwise, try to normalize it
                if str(common_parent) in clean_path:
                    clean_path = clean_path.replace(str(common_parent) + "/", "")
                valid_files.append(clean_path)

    selected_files = valid_files

    info(f"\nClaude selected {len(selected_files)} files:")
    for f in selected_files:
        info(f"  - {Colors.BLUE}{f}{Colors.RESET}")

    # Check if Claude returned fewer files than requested
    if len(selected_files) < num_files_to_analyze:
        warning(
            f"⚠️  Claude returned only {len(selected_files)} files instead of {num_files_to_analyze} requested"
        )
        warning("   Proceeding with the files that were selected...")
    elif len(selected_files) > num_files_to_analyze:
        info(
            f"📝 Claude returned {len(selected_files)} files, using first {num_files_to_analyze}"
        )
        selected_files = selected_files[:num_files_to_analyze]

    # Step 4: Verify the selected files exist
    info("\nVerifying selected HTML files...")
    verified_files = []

    for file_path in selected_files:
        file_path = file_path.strip()

        # First check if this path is exactly in our relative_paths list
        if file_path in relative_paths:
            # It's a valid path from our list
            full_path = common_parent / file_path
            if safe_exists(full_path):
                verified_files.append(file_path)
                success(f"✅ Found: {file_path}")
                continue

        # If not found exactly, try as a path relative to common_parent
        test_path = common_parent / file_path
        if safe_exists(test_path) and test_path.suffix.lower() in [".html", ".htm"]:
            try:
                rel_path = test_path.relative_to(common_parent)
                verified_files.append(str(rel_path))
                success(f"✅ Found: {rel_path}")
                continue
            except ValueError:
                pass

        # If still not found, log it as missing
        warning(f"⚠️  Not found: {file_path}")
        warning(f"   Expected it to be in: {common_parent}")

    if not verified_files:
        error("❌ No HTML files could be verified")
        return

    # Check if we have fewer verified files than requested
    if len(verified_files) < num_files_to_analyze:
        warning(
            f"⚠️  Only {len(verified_files)} files passed verification (requested {num_files_to_analyze})"
        )
        if len(verified_files) < len(selected_files):
            warning(
                f"   {len(selected_files) - len(verified_files)} files failed verification"
            )

    # Write the verified files to a reference list
    selected_files_path = m1f_dir / "selected_html_files.txt"
    with safe_open(selected_files_path, "w") as f:
        for file_path in verified_files:
            f.write(f"{file_path}\n")
    success(f"✅ Wrote selected files list to: {selected_files_path}")

    # Step 5: Analyze each file individually with Claude using subagents
    info(f"\n🚀 Analyzing {len(verified_files)} files using parallel subagents...")
    warning("⏱️  Expected duration: 2-3 minutes with parallel execution")
    info(
        f"   {Colors.DIM}Claude is coordinating subagents to analyze each file...{Colors.RESET}"
    )

    # Load the coordinated analysis prompt template
    coordinate_prompt_path = prompt_dir / "coordinate_parallel_analysis.md"

    if not safe_exists(coordinate_prompt_path):
        # Fall back to old approach if new prompt doesn't exist
        warning(
            "⚠️  Coordinated analysis prompt not found, using traditional parallel approach..."
        )

        # Load the individual analysis prompt template
        individual_prompt_path = prompt_dir / "analyze_individual_file.md"

        if not safe_exists(individual_prompt_path):
            error(f"❌ Prompt file not found: {individual_prompt_path}")
            return

        individual_prompt_template = safe_read_text(individual_prompt_path)

        # Prepare tasks for parallel execution
        tasks = []
        for i, file_path in enumerate(verified_files, 1):
            # Construct paths - use absolute path to ensure correct location
            # Analysis files go into the m1f/analysis directory
            output_path = str(analysis_dir / f"html_analysis_{i}.txt")

            # Customize prompt for this specific file
            individual_prompt = individual_prompt_template.replace(
                "{filename}", file_path
            )
            individual_prompt = individual_prompt.replace("{output_path}", output_path)
            individual_prompt = individual_prompt.replace("{file_number}", str(i))

            # Add project context if provided
            if project_description:
                individual_prompt = (
                    f"PROJECT CONTEXT: {project_description}\n\n{individual_prompt}"
                )

            tasks.append(
                {
                    "name": f"Analysis {i}: {file_path}",
                    "prompt": individual_prompt,
                    "add_dir": str(common_parent),
                    "allowed_tools": "Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write,Bash,Task",
                    "timeout": 300,  # 5 minutes per file
                    "working_dir": str(common_parent),  # Set working directory
                }
            )

        # Run analyses in parallel
        results = runner.run_claude_parallel(tasks, show_progress=True)

        # Check results
        successful_analyses = sum(1 for r in results if r["success"])
        success(
            f"\n✅ Successfully analyzed {successful_analyses}/{len(verified_files)} files"
        )

        # Show any errors
        for result in results:
            if not result["success"]:
                error(
                    f"❌ Failed: {result['name']} - {result.get('error') or result.get('stderr')}"
                )
    else:
        # Use new coordinated subagent approach
        coordinate_prompt_template = safe_read_text(coordinate_prompt_path)

        # Load individual analysis template for subagent instructions
        individual_prompt_path = prompt_dir / "analyze_individual_file.md"
        if not safe_exists(individual_prompt_path):
            error(f"❌ Individual analysis prompt not found: {individual_prompt_path}")
            return

        individual_prompt_template = safe_read_text(individual_prompt_path)

        # Build file list for the coordination prompt
        file_list = []
        for i, file_path in enumerate(verified_files, 1):
            file_list.append(f"- File {i}: {file_path}")

        # Prepare the coordination prompt
        coordinate_prompt = coordinate_prompt_template.replace(
            "{num_files}", str(len(verified_files))
        )
        coordinate_prompt = coordinate_prompt.replace(
            "{project_description}", project_description or ""
        )
        coordinate_prompt = coordinate_prompt.replace(
            "{file_list}", "\n".join(file_list)
        )
        coordinate_prompt = coordinate_prompt.replace(
            "{analysis_dir}", str(analysis_dir)
        )

        # Build the subagent instructions for each file
        subagent_instructions = []
        for i, file_path in enumerate(verified_files, 1):
            output_path = str(analysis_dir / f"html_analysis_{i}.txt")

            # Prepare individual analysis instructions
            individual_instructions = individual_prompt_template.replace(
                "{filename}", file_path
            )
            individual_instructions = individual_instructions.replace(
                "{output_path}", output_path
            )
            individual_instructions = individual_instructions.replace(
                "{file_number}", str(i)
            )

            subagent_instructions.append(
                {
                    "file_num": i,
                    "file_path": file_path,
                    "output_path": output_path,
                    "instructions": individual_instructions,
                }
            )

        # Add the detailed instructions to the coordination prompt
        detailed_instructions = "\n\n".join(
            [
                f"### File {inst['file_num']}: {inst['file_path']}\n"
                f"Output: {inst['output_path']}\n"
                f"Instructions:\n{inst['instructions']}"
                for inst in subagent_instructions
            ]
        )

        # Replace placeholder with actual detailed instructions
        coordinate_prompt = coordinate_prompt.replace(
            "{detailed_instructions}", detailed_instructions
        )

        info("\n📊 Launching coordinated analysis with subagents...")
        info(
            f"   Managing {len(verified_files)} parallel analyses through Task delegation"
        )

        # Run the coordinated analysis with real-time JSON streaming
        returncode, stdout, stderr = runner.run_claude_streaming_json(
            prompt=coordinate_prompt,
            allowed_tools="Task,TodoWrite,Read,Write,LS,Grep",  # Task for subagents, TodoWrite for tracking
            add_dir=str(common_parent),
            timeout=600,  # 10 minutes for coordination
            working_dir=str(common_parent),
            show_progress=True,  # Show real-time progress
        )

        if returncode != 0:
            error(f"❌ Coordinated analysis failed: {stderr}")
            return

        # Verify all analysis files were created
        successful_analyses = 0
        for i in range(1, len(verified_files) + 1):
            analysis_file = analysis_dir / f"html_analysis_{i}.txt"
            if safe_exists(analysis_file):
                successful_analyses += 1

        if successful_analyses == len(verified_files):
            success(
                f"\n✅ Successfully analyzed all {successful_analyses} files using subagents"
            )
        else:
            warning(f"\n⚠️  Analyzed {successful_analyses}/{len(verified_files)} files")
            warning(
                "   Some files may have failed - check the output above for details"
            )

    # Step 6: Synthesize all analyses into final config
    info("\n🔬 Synthesizing analyses into final configuration...")
    warning("⏱️  This final step typically takes 1-2 minutes...")

    # Load the synthesis prompt
    synthesis_prompt_path = prompt_dir / "synthesize_config.md"

    if not safe_exists(synthesis_prompt_path):
        error(f"❌ Prompt file not found: {synthesis_prompt_path}")
        return

    synthesis_prompt = safe_read_text(synthesis_prompt_path)

    # Update the synthesis prompt with the actual number of files analyzed
    synthesis_prompt = synthesis_prompt.replace(
        "analyzed 5 HTML files", f"analyzed {len(verified_files)} HTML files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "You have analyzed 5 HTML files",
        f"You have analyzed {len(verified_files)} HTML files",
    )

    # Build the file list dynamically with relative paths
    file_list = []
    for i in range(1, len(verified_files) + 1):
        # Use absolute paths for synthesis to ensure files are found
        analysis_file_path = str(analysis_dir / f"html_analysis_{i}.txt")
        file_list.append(f"- {analysis_file_path}")

    # Replace the static file list with the dynamic one
    old_file_list = """Read the 5 analysis files:
- m1f/analysis/html_analysis_1.txt
- m1f/analysis/html_analysis_2.txt  
- m1f/analysis/html_analysis_3.txt
- m1f/analysis/html_analysis_4.txt
- m1f/analysis/html_analysis_5.txt"""

    new_file_list = f"Read the {len(verified_files)} analysis files:\n" + "\n".join(
        file_list
    )
    synthesis_prompt = synthesis_prompt.replace(old_file_list, new_file_list)

    # Update other references
    synthesis_prompt = synthesis_prompt.replace(
        "Analyzed 5 files", f"Analyzed {len(verified_files)} files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "works on X/5 files", f"works on X/{len(verified_files)} files"
    )
    synthesis_prompt = synthesis_prompt.replace(
        "found in X/5 files", f"found in X/{len(verified_files)} files"
    )

    # Add project context if provided
    if project_description:
        synthesis_prompt = (
            f"PROJECT CONTEXT: {project_description}\n\n{synthesis_prompt}"
        )

    # Run synthesis with real-time streaming output
    info("\nRunning synthesis with Claude...")
    returncode, stdout, stderr = runner.run_claude_streaming_json(
        prompt=synthesis_prompt,
        add_dir=str(common_parent),
        timeout=300,  # 5 minutes for synthesis
        working_dir=str(common_parent),
        show_progress=True,
    )

    if returncode != 0:
        error(f"❌ Synthesis failed: {stderr}")
        return

    # Parse JSON output to extract Claude's actual text response (for synthesis)
    synthesis_text_output = []

    for line in stdout.strip().split("\n"):
        if not line.strip():
            continue
        try:
            json_obj = json.loads(line)
            # Extract text from assistant messages
            if json_obj.get("type") == "assistant":
                message = json_obj.get("message", {})
                if isinstance(message, dict):
                    content_parts = message.get("content", [])
                    if isinstance(content_parts, list):
                        for part in content_parts:
                            if isinstance(part, dict) and part.get("type") == "text":
                                text = part.get("text", "")
                                if text:
                                    synthesis_text_output.append(text)
        except json.JSONDecodeError:
            # If it's not JSON, might be plain text (backwards compatibility)
            synthesis_text_output.append(line)

    # Join all text outputs
    full_synthesis_text = "\n".join(synthesis_text_output)

    header("\n✨ Claude's Final Configuration:")
    info(
        full_synthesis_text[:2000] + "..."
        if len(full_synthesis_text) > 2000
        else full_synthesis_text
    )

    # Try to parse the YAML config from Claude's output
    import yaml

    try:
        # Extract YAML from the output (between ```yaml and ```)
        output = full_synthesis_text
        yaml_start = output.find("```yaml")
        yaml_end = output.find("```", yaml_start + 6)

        if yaml_start != -1 and yaml_end != -1:
            yaml_content = output[yaml_start + 7 : yaml_end].strip()
            config_data = yaml.safe_load(yaml_content)

            # Clean up the config - remove empty strings
            if "extractor" in config_data:
                extractor = config_data["extractor"]
                if "alternative_selectors" in extractor:
                    extractor["alternative_selectors"] = [
                        s for s in extractor["alternative_selectors"] if s
                    ]
                if "ignore_selectors" in extractor:
                    extractor["ignore_selectors"] = [
                        s for s in extractor["ignore_selectors"] if s
                    ]

            # Save the config to a file
            config_path = common_parent / "m1f-html2md-config.yaml"
            with safe_open(config_path, "w") as f:
                yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

            success(f"\n✅ Saved configuration to: {config_path}")
            info(
                "\nYou can now use this configuration file to convert your HTML files:"
            )
            info(
                f"  {Colors.BLUE}m1f-html2md convert {common_parent} -c {config_path} -o ./output/{Colors.RESET}"
            )
        else:
            warning("\n⚠️  Could not extract YAML config from Claude's response")
            # Save the full response for manual review
            full_response_path = common_parent / "m1f-html2md-claude-response.txt"
            with safe_open(full_response_path, "w") as f:
                f.write(full_synthesis_text)
            warning(f"  Saved Claude's full response to: {full_response_path}")
            warning("  Please review the response and create the config file manually.")

    except yaml.YAMLError as e:
        warning(f"\n⚠️  Error parsing YAML config: {e}")
        # Save the full response for manual review
        full_response_path = common_parent / "m1f-html2md-claude-response.txt"
        with safe_open(full_response_path, "w") as f:
            f.write(full_synthesis_text)
        warning(f"  Saved Claude's full response to: {full_response_path}")
        warning("  Please review the response and create the config file manually.")
    except Exception as e:
        warning(f"\n⚠️  Error saving config: {e}")
        # Try to save the full response at least
        try:
            full_response_path = common_parent / "m1f-html2md-claude-response.txt"
            with safe_open(full_response_path, "w") as f:
                f.write(full_synthesis_text)
            warning(f"  Saved Claude's full response to: {full_response_path}")
        except:
            pass

    success(f"\n✅ {Colors.BOLD}Analysis complete!{Colors.RESET}")

======= html2md_tool/convert_claude.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Improved Claude conversion functions for HTML to Markdown converter."""

import os
import sys
import time
import tempfile
from pathlib import Path
from typing import List
from html2md_tool.claude_runner import ClaudeRunner

# Import safe file operations
from m1f.file_operations import (
    safe_exists,
    safe_is_file,
    safe_is_dir,
    safe_mkdir,
    safe_read_text,
)

# Use unified colorama module
from shared.colors import (
    Colors,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)


def handle_claude_convert_improved(args):
    """Handle conversion using Claude AI with improved timeout handling."""

    header(
        f"{Colors.BOLD}Using Claude AI to convert HTML to Markdown (with improved streaming)...{Colors.RESET}"
    )
    info(f"Model: {args.model}")
    info(f"Sleep between calls: {args.sleep} seconds")

    # Get source path first
    source_path = args.source

    # Initialize Claude runner
    try:
        runner = ClaudeRunner(
            working_dir=str(
                source_path.parent if safe_is_file(source_path) else source_path
            )
        )
    except Exception as e:
        error(str(e))
        sys.exit(1)

    # Find all HTML files in source directory
    if not safe_exists(source_path):
        error(f"Source path not found: {source_path}")
        sys.exit(1)

    html_files = []
    if safe_is_file(source_path):
        if source_path.suffix.lower() in [".html", ".htm"]:
            html_files.append(source_path)
        else:
            error(f"Source file is not HTML: {source_path}")
            sys.exit(1)
    elif safe_is_dir(source_path):
        # Find all HTML files recursively
        html_files = list(source_path.rglob("*.html")) + list(
            source_path.rglob("*.htm")
        )
        info(f"Found {len(html_files)} HTML files in {source_path}")

    if not html_files:
        error("No HTML files found to convert")
        sys.exit(1)

    # Prepare output directory
    output_path = args.output
    if safe_exists(output_path) and safe_is_file(output_path):
        error(f"Output path is a file, expected directory: {output_path}")
        sys.exit(1)

    if not safe_exists(output_path):
        output_path.mkdir(parents=True, exist_ok=True)
        info(f"Created output directory: {output_path}")

    # Load conversion prompt
    prompt_path = Path(__file__).parent / "prompts" / "convert_html_to_md.md"
    if not safe_exists(prompt_path):
        error(f"Prompt file not found: {prompt_path}")
        sys.exit(1)

    prompt_template = safe_read_text(prompt_path)

    # Process each HTML file
    converted_count = 0
    failed_count = 0

    for i, html_file in enumerate(html_files):
        tmp_html_path = None
        try:
            # Import validate_path_traversal from m1f tool
            from m1f.utils import validate_path_traversal

            # Validate path to prevent traversal attacks
            validated_path = validate_path_traversal(
                html_file,
                base_path=(
                    source_path if safe_is_dir(source_path) else source_path.parent
                ),
                allow_outside=False,
            )

            # Read HTML content
            html_content = validated_path.read_text(encoding="utf-8")

            # Determine output file path
            if safe_is_file(source_path):
                # Single file conversion
                output_file = output_path / html_file.with_suffix(".md").name
            else:
                # Directory conversion - maintain structure
                relative_path = html_file.relative_to(source_path)
                output_file = output_path / relative_path.with_suffix(".md")

            # Create output directory if needed
            output_file.parent.mkdir(parents=True, exist_ok=True)

            info(f"\n[{i+1}/{len(html_files)}] Converting: {html_file.name}")

            # Create a temporary file with the HTML content
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".html", delete=False, encoding="utf-8"
            ) as tmp_html:
                tmp_html.write(html_content)
                tmp_html_path = tmp_html.name

            # Prepare the prompt for the temporary file
            prompt = prompt_template.replace("{html_content}", f"@{tmp_html_path}")

            # Add model parameter to prompt
            prompt = f"{prompt}\n\nNote: Using model {args.model}"

            # Use improved Claude runner with streaming
            info(f"{Colors.DIM}🔄 Converting with Claude...{Colors.RESET}")
            returncode, stdout, stderr = runner.run_claude_streaming(
                prompt=prompt,
                allowed_tools="Agent,Edit,Glob,Grep,LS,MultiEdit,Read,TodoRead,TodoWrite,WebFetch,WebSearch,Write",  # All tools except Bash and Notebook*
                timeout=300,  # 5 minutes per file
                show_output=False,  # Don't show Claude's thinking process
            )

            if returncode != 0:
                error(f"Claude conversion failed: {stderr}")
                failed_count += 1
                continue

            # Save the markdown output
            markdown_content = stdout.strip()

            # Clean up any Claude metadata if present
            if "Claude:" in markdown_content:
                # Remove any Claude: prefixed lines
                lines = markdown_content.split("\n")
                cleaned_lines = [
                    line for line in lines if not line.strip().startswith("Claude:")
                ]
                markdown_content = "\n".join(cleaned_lines)

            output_file.write_text(markdown_content, encoding="utf-8")
            success(f"Converted to: {output_file}")
            converted_count += 1

            # Sleep between API calls (except for the last one)
            if i < len(html_files) - 1 and args.sleep > 0:
                info(f"{Colors.DIM}Sleeping for {args.sleep} seconds...{Colors.RESET}")
                time.sleep(args.sleep)

        except Exception as e:
            error(f"Error processing {html_file}: {e}")
            failed_count += 1

        finally:
            # Clean up temporary file
            if tmp_html_path and safe_exists(Path(tmp_html_path)):
                try:
                    os.unlink(tmp_html_path)
                except Exception:
                    pass

    # Summary
    success(f"{Colors.BOLD}Conversion complete!{Colors.RESET}")
    info(f"Successfully converted: {converted_count} files")
    if failed_count > 0:
        warning(f"Failed: {failed_count} files")

    info(f"\nOutput directory: {output_path}")

======= html2md_tool/core.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Core HTML parsing and Markdown conversion functionality."""

import re
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urljoin, urlparse

from bs4 import BeautifulSoup, NavigableString, Tag
from markdownify import markdownify

# Import safe file operations
from m1f.file_operations import safe_open

from html2md_tool.config.models import ExtractorConfig, ProcessorConfig


class HTMLParser:
    """HTML parsing and extraction."""

    def __init__(self, config: ExtractorConfig):
        """Initialize parser with configuration."""
        self.config = config

    def parse(self, html: str, base_url: Optional[str] = None) -> BeautifulSoup:
        """Parse HTML content.

        Args:
            html: HTML content
            base_url: Base URL for resolving relative links

        Returns:
            BeautifulSoup object
        """
        soup = BeautifulSoup(html, self.config.parser)

        if base_url:
            self._resolve_urls(soup, base_url)

        if self.config.prettify:
            return BeautifulSoup(soup.prettify(), self.config.parser)

        return soup

    def parse_file(self, file_path, output_path=None) -> BeautifulSoup:
        """Parse HTML file.

        Args:
            file_path: Path to HTML file
            output_path: Optional output path for relative link resolution

        Returns:
            BeautifulSoup object
        """
        from pathlib import Path

        file_path = Path(file_path)

        # Read file with proper encoding detection
        encodings = [self.config.encoding, "utf-8", "latin-1", "cp1252"]
        html_content = None

        for encoding in encodings:
            try:
                with safe_open(file_path, "r", encoding=encoding) as f:
                    html_content = f.read()
                break
            except (UnicodeDecodeError, LookupError):
                continue

        if html_content is None:
            # Fallback: read as binary and decode with errors='ignore'
            with safe_open(file_path, "rb") as f:
                html_content = f.read().decode(
                    self.config.encoding, errors=self.config.decode_errors
                )

        # Don't use file:// URLs - they cause absolute path issues
        # Instead, we'll handle relative links in a post-processing step
        base_url = None

        return self.parse(html_content, base_url)

    def _resolve_urls(self, soup: BeautifulSoup, base_url: str) -> None:
        """Resolve relative URLs to absolute.

        Args:
            soup: BeautifulSoup object
            base_url: Base URL
        """
        # Parse base URL to check if it's a file:// URL
        parsed_base = urlparse(base_url)
        is_file_url = parsed_base.scheme == "file"

        # Resolve links
        for tag in soup.find_all(["a", "link"]):
            if href := tag.get("href"):
                # Skip javascript: and mailto: links
                if href.startswith(("javascript:", "mailto:", "#")):
                    continue

                # For file:// base URLs, convert relative links to relative paths
                if is_file_url:
                    if not href.startswith(("http://", "https://", "//")):
                        # Keep relative links as-is for file:// URLs
                        continue

                tag["href"] = urljoin(base_url, href)

        # Resolve images and other resources
        for tag in soup.find_all(["img", "script", "source"]):
            if src := tag.get("src"):
                # For file:// base URLs, keep relative paths
                if is_file_url:
                    if not src.startswith(("http://", "https://", "//")):
                        continue

                tag["src"] = urljoin(base_url, src)

    def extract_metadata(self, soup: BeautifulSoup) -> Dict[str, str]:
        """Extract metadata from HTML.

        Args:
            soup: BeautifulSoup object

        Returns:
            Dictionary of metadata
        """
        metadata = {}

        # Title
        if title := soup.find("title"):
            metadata["title"] = title.get_text(strip=True)

        # Meta tags
        for meta in soup.find_all("meta"):
            if name := meta.get("name"):
                if content := meta.get("content"):
                    metadata[name] = content
            elif prop := meta.get("property"):
                if content := meta.get("content"):
                    metadata[prop] = content

        return metadata


class MarkdownConverter:
    """Convert HTML to Markdown."""

    def __init__(self, config: ProcessorConfig):
        """Initialize converter with configuration."""
        self.config = config

    def convert(
        self, soup: BeautifulSoup, options: Optional[Dict[str, Any]] = None
    ) -> str:
        """Convert BeautifulSoup object to Markdown.

        Args:
            soup: BeautifulSoup object
            options: Additional conversion options

        Returns:
            Markdown content
        """
        # Pre-process code blocks to preserve language info
        for code_block in soup.find_all("code"):
            if code_block.parent and code_block.parent.name == "pre":
                # Get language from class
                classes = code_block.get("class", [])
                for cls in classes:
                    if cls.startswith("language-"):
                        lang = cls.replace("language-", "")
                        # Add language marker
                        code_block.string = f"```{lang}\n{code_block.get_text()}\n```"
                        code_block.parent.unwrap()  # Remove pre tag
                        break

        # Merge options
        opts = {
            "heading_style": "atx",
            "bullets": "-",
            "code_language": "",
            "strip": ["script", "style"],
        }
        if options:
            opts.update(options)

        # Remove script and style tags before conversion
        for tag in soup.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Convert to markdown
        markdown = markdownify(str(soup), **opts)

        # Post-process
        markdown = self._post_process(markdown)

        # Add frontmatter if enabled
        if self.config.frontmatter and self.config.metadata:
            markdown = self._add_frontmatter(markdown)

        # Add TOC if enabled
        if self.config.toc:
            markdown = self._add_toc(markdown)

        return markdown

    def _post_process(self, markdown: str) -> str:
        """Post-process markdown content.

        Args:
            markdown: Raw markdown

        Returns:
            Processed markdown
        """
        # Remove excessive blank lines
        markdown = re.sub(r"\n{3,}", "\n\n", markdown)

        # Fix spacing around headings
        markdown = re.sub(r"(^|\n)(#{1,6})\s+", r"\1\n\2 ", markdown)

        # Ensure single blank line before headings
        markdown = re.sub(r"([^\n])\n(#{1,6})\s+", r"\1\n\n\2 ", markdown)

        # Fix list formatting
        markdown = re.sub(r"(\n\s*[-*+]\s+)", r"\n\1", markdown)

        # Trim
        return markdown.strip()

    def _add_frontmatter(self, markdown: str) -> str:
        """Add frontmatter to markdown.

        Args:
            markdown: Markdown content

        Returns:
            Markdown with frontmatter
        """
        import yaml

        frontmatter = yaml.dump(self.config.metadata, default_flow_style=False)
        return f"---\n{frontmatter}---\n\n{markdown}"

    def _add_toc(self, markdown: str) -> str:
        """Add table of contents to markdown.

        Args:
            markdown: Markdown content

        Returns:
            Markdown with TOC
        """
        toc_lines = ["## Table of Contents\n"]

        # Extract headings
        heading_pattern = re.compile(r"^(#{1,6})\s+(.+)$", re.MULTILINE)

        for match in heading_pattern.finditer(markdown):
            level = len(match.group(1))
            if level <= self.config.toc_depth:
                title = match.group(2)
                indent = "  " * (level - 1)
                anchor = re.sub(r"[^\w\s-]", "", title.lower())
                anchor = re.sub(r"\s+", "-", anchor)
                toc_lines.append(f"{indent}- [{title}](#{anchor})")

        if len(toc_lines) > 1:
            toc = "\n".join(toc_lines) + "\n\n"
            return toc + markdown

        return markdown

======= html2md_tool/extractors.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Custom extractor system for mf1-html2md."""

import importlib.util
import sys
from pathlib import Path
from typing import Optional, Dict, Any
from bs4 import BeautifulSoup
from html2md_tool.utils import get_logger

# Import safe file operations
from m1f.file_operations import safe_exists

logger = get_logger(__name__)


class BaseExtractor:
    """Base class for custom extractors."""

    def extract(
        self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
    ) -> BeautifulSoup:
        """Extract content from HTML soup.

        Args:
            soup: BeautifulSoup object
            config: Optional configuration dict

        Returns:
            Processed BeautifulSoup object
        """
        raise NotImplementedError("Subclasses must implement extract()")

    def preprocess(self, html: str, config: Optional[Dict[str, Any]] = None) -> str:
        """Optional preprocessing of raw HTML.

        Args:
            html: Raw HTML string
            config: Optional configuration dict

        Returns:
            Preprocessed HTML string
        """
        return html

    def postprocess(
        self, markdown: str, config: Optional[Dict[str, Any]] = None
    ) -> str:
        """Optional postprocessing of converted markdown.

        Args:
            markdown: Converted markdown string
            config: Optional configuration dict

        Returns:
            Postprocessed markdown string
        """
        return markdown


def load_extractor(extractor_path: Path) -> BaseExtractor:
    """Load a custom extractor from a Python file.

    Args:
        extractor_path: Path to the extractor Python file

    Returns:
        Extractor instance

    Raises:
        ValueError: If extractor cannot be loaded
    """
    if not safe_exists(extractor_path):
        raise ValueError(f"Extractor file not found: {extractor_path}")

    # Load the module dynamically
    spec = importlib.util.spec_from_file_location("custom_extractor", extractor_path)
    if spec is None or spec.loader is None:
        raise ValueError(f"Cannot load extractor from {extractor_path}")

    module = importlib.util.module_from_spec(spec)
    sys.modules["custom_extractor"] = module
    spec.loader.exec_module(module)

    # Look for extractor class or function
    if hasattr(module, "Extractor") and isinstance(module.Extractor, type):
        # Class-based extractor
        return module.Extractor()
    elif hasattr(module, "extract"):
        # Function-based extractor - wrap in a class
        class FunctionExtractor(BaseExtractor):
            def extract(
                self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
            ) -> BeautifulSoup:
                return module.extract(soup, config)

            def preprocess(
                self, html: str, config: Optional[Dict[str, Any]] = None
            ) -> str:
                if hasattr(module, "preprocess"):
                    return module.preprocess(html, config)
                return html

            def postprocess(
                self, markdown: str, config: Optional[Dict[str, Any]] = None
            ) -> str:
                if hasattr(module, "postprocess"):
                    return module.postprocess(markdown, config)
                return markdown

        return FunctionExtractor()
    else:
        raise ValueError(
            f"Extractor must define either an 'Extractor' class or an 'extract' function"
        )


class DefaultExtractor(BaseExtractor):
    """Default extractor with basic cleaning."""

    def extract(
        self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
    ) -> BeautifulSoup:
        """Basic extraction that removes common navigation elements."""
        # Remove script and style tags
        for tag in soup.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Remove common navigation elements
        nav_selectors = [
            "nav",
            '[role="navigation"]',
            "header",
            '[role="banner"]',
            "footer",
            '[role="contentinfo"]',
            ".sidebar",
            "aside",
            '[role="search"]',
            ".menu",
            ".toolbar",
        ]

        for selector in nav_selectors:
            for elem in soup.select(selector):
                elem.decompose()

        return soup

======= html2md_tool/preprocessors.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""HTML preprocessors for cleaning up content before conversion."""

from bs4 import BeautifulSoup, Comment
import re
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, field


@dataclass
class PreprocessingConfig:
    """Configuration for HTML preprocessing."""

    # Elements to completely remove
    remove_elements: List[str] = field(default_factory=lambda: ["script", "style"])

    # CSS selectors for elements to remove
    remove_selectors: List[str] = field(default_factory=list)

    # ID selectors for elements to remove
    remove_ids: List[str] = field(default_factory=list)

    # Class names for elements to remove
    remove_classes: List[str] = field(default_factory=list)

    # Comments containing these strings will be removed
    remove_comments_containing: List[str] = field(default_factory=list)

    # Text patterns to remove (regex)
    remove_text_patterns: List[str] = field(default_factory=list)

    # URL patterns to fix (from -> to)
    fix_url_patterns: Dict[str, str] = field(default_factory=dict)

    # Remove empty elements
    remove_empty_elements: bool = True

    # Custom processing function name
    custom_processor: Optional[str] = None


class GenericPreprocessor:
    """Generic HTML preprocessor based on configuration."""

    def __init__(self, config: PreprocessingConfig):
        self.config = config

    def preprocess(self, soup: BeautifulSoup) -> BeautifulSoup:
        """Apply preprocessing based on configuration."""

        # Remove specified elements
        for tag_name in self.config.remove_elements:
            for tag in soup.find_all(tag_name):
                tag.extract()

        # Remove elements by CSS selector
        for selector in self.config.remove_selectors:
            for element in soup.select(selector):
                element.extract()

        # Remove elements by ID
        for element_id in self.config.remove_ids:
            element = soup.find(id=element_id)
            if element:
                element.extract()

        # Remove elements by class
        for class_name in self.config.remove_classes:
            for element in soup.find_all(class_=class_name):
                element.extract()

        # Remove comments containing specific text
        if self.config.remove_comments_containing:
            for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):
                comment_text = str(comment)
                for pattern in self.config.remove_comments_containing:
                    if pattern in comment_text:
                        comment.extract()
                        break

        # Remove text matching patterns
        if self.config.remove_text_patterns:
            for pattern in self.config.remove_text_patterns:
                regex = re.compile(pattern)
                for text in soup.find_all(string=regex):
                    if text.parent and text.parent.name not in ["script", "style"]:
                        text.replace_with("")

        # Fix URLs
        if self.config.fix_url_patterns:
            for tag in soup.find_all(["a", "link", "img", "script"]):
                for attr in ["href", "src"]:
                    if url := tag.get(attr):
                        for (
                            pattern,
                            replacement,
                        ) in self.config.fix_url_patterns.items():
                            if pattern in url:
                                tag[attr] = url.replace(pattern, replacement)

        # Remove empty elements
        if self.config.remove_empty_elements:
            # Multiple passes to catch nested empty elements
            for _ in range(3):
                for tag in soup.find_all():
                    if (
                        tag.name not in ["img", "br", "hr", "input", "meta", "link"]
                        and not tag.get_text(strip=True)
                        and not tag.find_all(
                            ["img", "table", "ul", "ol", "video", "audio", "iframe"]
                        )
                    ):
                        tag.extract()

        return soup


def preprocess_html(html_content: str, config: PreprocessingConfig) -> str:
    """Preprocess HTML content before conversion.

    Args:
        html_content: Raw HTML content
        config: Preprocessing configuration

    Returns:
        Cleaned HTML content
    """
    soup = BeautifulSoup(html_content, "html.parser")

    preprocessor = GenericPreprocessor(config)
    soup = preprocessor.preprocess(soup)

    return str(soup)

======= html2md_tool/utils.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility functions for mf1-html2md."""

import logging
from pathlib import Path
from typing import Optional

from shared.logging import (
    get_logger as shared_get_logger,
    configure_logging as shared_configure_logging,
)


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance.

    Args:
        name: Logger name

    Returns:
        Logger instance
    """
    return shared_get_logger(name)


def configure_logging(
    verbose: bool = False, quiet: bool = False, log_file: Optional[Path] = None
) -> None:
    """Configure logging for the application.

    Args:
        verbose: Enable verbose logging
        quiet: Suppress all but error messages
        log_file: Optional log file path
    """
    # Use the shared configure_logging function
    shared_configure_logging(verbose=verbose, quiet=quiet, log_file=log_file)

    # Suppress some noisy loggers specific to html2md
    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("requests").setLevel(logging.WARNING)


def validate_url(url: str) -> bool:
    """Validate URL format.

    Args:
        url: URL to validate

    Returns:
        True if valid, False otherwise
    """
    from urllib.parse import urlparse

    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except Exception:
        return False


def sanitize_filename(filename: str) -> str:
    """Sanitize filename for filesystem.

    Args:
        filename: Original filename

    Returns:
        Sanitized filename
    """
    import re

    # Remove invalid characters
    filename = re.sub(r'[<>:"/\\|?*]', "_", filename)

    # Remove control characters
    filename = re.sub(r"[\x00-\x1f\x7f]", "", filename)

    # Limit length
    if len(filename) > 200:
        filename = filename[:200]

    # Ensure not empty
    if not filename:
        filename = "untitled"

    return filename


def format_size(size: int) -> str:
    """Format byte size to human readable format.

    Args:
        size: Size in bytes

    Returns:
        Formatted size string
    """
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} PB"


def convert_html(
    html_content: str,
    base_url: Optional[str] = None,
    convert_code_blocks: bool = False,
    heading_offset: int = 0,
) -> str:
    """Convert HTML content to Markdown.

    Args:
        html_content: HTML content as string
        base_url: Optional base URL for resolving relative links
        convert_code_blocks: Whether to convert code blocks to fenced style
        heading_offset: Offset to apply to heading levels

    Returns:
        Markdown content
    """
    from html2md_tool.config.models import ExtractorConfig, ProcessorConfig
    from html2md_tool.core import HTMLParser, MarkdownConverter

    # Create default configs
    extractor_config = ExtractorConfig()
    processor_config = ProcessorConfig()

    # Parse HTML
    parser = HTMLParser(extractor_config)
    soup = parser.parse(html_content, base_url)

    # Apply heading offset if needed
    if heading_offset != 0:
        # Collect all heading tags first to avoid processing them multiple times
        headings = []
        for i in range(1, 7):
            headings.extend([(tag, i) for tag in soup.find_all(f"h{i}")])

        # Now modify them
        for tag, level in headings:
            new_level = max(1, min(6, level + heading_offset))
            tag.name = f"h{new_level}"

    # Convert to Markdown
    converter = MarkdownConverter(processor_config)
    options = {}
    if convert_code_blocks:
        options["code_language"] = "python"
        options["code_block_style"] = "fenced"

    result = converter.convert(soup, options)

    # Handle code blocks if needed
    if convert_code_blocks:
        import re

        # Convert indented code blocks to fenced
        result = re.sub(r"^    (.+)$", r"```\n\1\n```", result, flags=re.MULTILINE)
        # Fix language-specific code blocks
        result = re.sub(
            r'```\n(.*?)class="language-(\w+)"(.*?)\n```',
            r"```\2\n\1\3\n```",
            result,
            flags=re.DOTALL,
        )

    return result


def adjust_internal_links(content, base_path: str = ""):
    """Adjust internal links in HTML/Markdown content.

    Args:
        content: BeautifulSoup object or Markdown string
        base_path: Base path for links

    Returns:
        Modified string if content is string, None if BeautifulSoup (modifies in place)
    """
    from bs4 import BeautifulSoup

    if isinstance(content, str):
        # If string is passed, work with markdown links
        import re

        # Pattern for markdown links
        link_pattern = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

        def replace_link(match):
            text = match.group(1)
            url = match.group(2)

            # Skip external links
            if url.startswith(("http://", "https://", "#", "mailto:")):
                return match.group(0)

            # Adjust internal link
            if base_path and not url.startswith("/"):
                url = f"{base_path}/{url}"

            # Convert .html/.htm to .md
            if url.endswith(".html"):
                url = url[:-5] + ".md"
            elif url.endswith(".htm"):
                url = url[:-4] + ".md"

            return f"[{text}]({url})"

        return link_pattern.sub(replace_link, content)
    else:
        # Work with BeautifulSoup object - modify in place
        for link in content.find_all("a"):
            href = link.get("href")
            if href:
                # Skip external links
                if not href.startswith(("http://", "https://", "#", "mailto:")):
                    # Adjust internal link
                    if base_path and not href.startswith("/"):
                        href = f"{base_path}/{href}"

                    # Convert .html/.htm to .md
                    if href.endswith(".html"):
                        href = href[:-5] + ".md"
                    elif href.endswith(".htm"):
                        href = href[:-4] + ".md"

                    link["href"] = href


def extract_title_from_html(html_content) -> Optional[str]:
    """Extract title from HTML content.

    Args:
        html_content: HTML content as string or BeautifulSoup object

    Returns:
        Title if found, None otherwise
    """
    from bs4 import BeautifulSoup

    if isinstance(html_content, str):
        soup = BeautifulSoup(html_content, "html.parser")
    else:
        # Already a BeautifulSoup object
        soup = html_content

    # Try <title> tag first
    if title_tag := soup.find("title"):
        return title_tag.get_text(strip=True)

    # Try <h1> tag
    if h1_tag := soup.find("h1"):
        return h1_tag.get_text(strip=True)

    # Try meta title
    if meta_title := soup.find("meta", {"name": "title"}):
        if content := meta_title.get("content"):
            return content

    # Try og:title
    if og_title := soup.find("meta", {"property": "og:title"}):
        if content := og_title.get("content"):
            return content

    return None


def create_progress_bar():
    """Create a simple text-based progress indicator.

    Note: Rich progress bars are no longer used. This returns None
    and calling code should handle progress display differently.

    Returns:
        None
    """
    return None

======= html2md_tool/config/__init__.py ======
"""Configuration system for mf1-html2md."""

from html2md_tool.config.loader import load_config, save_config
from html2md_tool.config.models import (
    AssetConfig,
    Config,
    ConversionOptions,
    CrawlerConfig,
    ExtractorConfig,
    M1fConfig,
    OutputFormat,
    ProcessorConfig,
)

__all__ = [
    "AssetConfig",
    "Config",
    "ConversionOptions",
    "CrawlerConfig",
    "ExtractorConfig",
    "M1fConfig",
    "OutputFormat",
    "ProcessorConfig",
    "load_config",
    "save_config",
]

======= html2md_tool/config/loader.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Configuration loading and saving utilities."""

import json
from pathlib import Path
from typing import Any, Dict
import warnings
from dataclasses import fields

import yaml
import sys

# Import safe file operations
from m1f.file_operations import safe_exists, safe_open

# Use unified colorama module
from shared.colors import (
    Colors,
    success,
    error,
    warning,
    info,
    header,
    COLORAMA_AVAILABLE,
)

from html2md_tool.config.models import Config


def load_config(path: Path) -> Config:
    """Load configuration from file.

    Args:
        path: Path to configuration file (JSON or YAML)

    Returns:
        Config object

    Raises:
        ValueError: If file format is not supported
        FileNotFoundError: If file does not exist
    """
    if not safe_exists(path):
        raise FileNotFoundError(f"Configuration file not found: {path}")

    suffix = path.suffix.lower()

    if suffix in [".json"]:
        with safe_open(path, "r") as f:
            data = json.load(f)
    elif suffix in [".yaml", ".yml"]:
        with safe_open(path, "r") as f:
            data = yaml.safe_load(f)
    else:
        raise ValueError(f"Unsupported configuration format: {suffix}")

    # Import nested config models
    from html2md_tool.config.models import (
        ConversionOptions,
        ExtractorConfig,
        ProcessorConfig,
        AssetConfig,
        CrawlerConfig,
        M1fConfig,
    )

    # Get valid field names from Config dataclass
    valid_fields = {f.name for f in fields(Config)}

    # Filter out unknown fields and warn about them
    filtered_data = {}
    unknown_fields = []

    for key, value in data.items():
        if key in valid_fields:
            # Convert string paths to Path objects for specific fields
            if key in ["source", "destination", "log_file"] and value is not None:
                filtered_data[key] = Path(value)
            # Handle nested configuration objects
            elif key == "conversion" and isinstance(value, dict):
                filtered_data[key] = ConversionOptions(**value)
            elif key == "extractor" and isinstance(value, dict):
                filtered_data[key] = ExtractorConfig(**value)
            elif key == "processor" and isinstance(value, dict):
                filtered_data[key] = ProcessorConfig(**value)
            elif key == "assets" and isinstance(value, dict):
                filtered_data[key] = AssetConfig(**value)
            elif key == "crawler" and isinstance(value, dict):
                filtered_data[key] = CrawlerConfig(**value)
            elif key == "m1f" and isinstance(value, dict):
                filtered_data[key] = M1fConfig(**value)
            else:
                filtered_data[key] = value
        else:
            unknown_fields.append(key)

    # Warn about unknown fields
    if unknown_fields:
        warning(f"Ignoring unknown configuration fields: {', '.join(unknown_fields)}")
        info(
            f"{Colors.DIM}   These fields are not recognized by m1f-html2md and will be ignored.{Colors.RESET}"
        )

    return Config(**filtered_data)


def save_config(config: Config, path: Path) -> None:
    """Save configuration to file.

    Args:
        config: Config object to save
        path: Path to save configuration to

    Raises:
        ValueError: If file format is not supported
    """
    suffix = path.suffix.lower()

    # Convert dataclass to dict
    data = _config_to_dict(config)

    if suffix in [".json"]:
        with safe_open(path, "w") as f:
            json.dump(data, f, indent=2)
    elif suffix in [".yaml", ".yml"]:
        with safe_open(path, "w") as f:
            yaml.dump(data, f, default_flow_style=False)
    else:
        raise ValueError(f"Unsupported configuration format: {suffix}")


def _config_to_dict(config: Config) -> Dict[str, Any]:
    """Convert Config object to dictionary.

    Args:
        config: Config object

    Returns:
        Dictionary representation
    """
    from dataclasses import asdict

    data = asdict(config)

    # Convert Path objects to strings
    def convert_paths(obj):
        if isinstance(obj, dict):
            return {k: convert_paths(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [convert_paths(v) for v in obj]
        elif isinstance(obj, Path):
            return str(obj)
        else:
            return obj

    return convert_paths(data)

======= html2md_tool/config/models.py ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Configuration models for mf1-html2md."""

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set


class OutputFormat(Enum):
    """Output format options."""

    MARKDOWN = "markdown"
    HTML = "html"
    JSON = "json"


class ScraperBackend(str, Enum):
    """Available web scraper backends."""

    HTTRACK = "httrack"
    BEAUTIFULSOUP = "beautifulsoup"
    BS4 = "bs4"  # Alias for beautifulsoup
    SCRAPY = "scrapy"
    PLAYWRIGHT = "playwright"
    SELECTOLAX = "selectolax"
    HTTPX = "httpx"  # Alias for selectolax


@dataclass
class ConversionOptions:
    """Options for HTML to Markdown conversion."""

    strip_tags: List[str] = field(default_factory=lambda: ["script", "style"])
    keep_html_tags: List[str] = field(default_factory=list)
    code_language: str = ""
    heading_style: str = "atx"  # atx or setext
    bold_style: str = "**"  # ** or __
    italic_style: str = "*"  # * or _
    link_style: str = "inline"  # inline or reference
    list_marker: str = "-"  # -, *, or +
    code_block_style: str = "fenced"  # fenced or indented
    preserve_whitespace: bool = False
    wrap_width: int = 0  # 0 means no wrapping

    # Additional fields for test compatibility
    source_dir: Optional[str] = None
    destination_dir: Optional[Path] = None
    destination_directory: Optional[Path] = None  # Alias for destination_dir
    outermost_selector: Optional[str] = None
    ignore_selectors: Optional[List[str]] = None
    heading_offset: int = 0
    generate_frontmatter: bool = False
    add_frontmatter: bool = False  # Alias for generate_frontmatter
    frontmatter_fields: Optional[Dict[str, str]] = None
    convert_code_blocks: bool = True
    parallel: bool = False
    max_workers: int = 4

    def __post_init__(self):
        # Handle aliases
        if self.add_frontmatter:
            self.generate_frontmatter = True
        if self.destination_directory:
            self.destination_dir = self.destination_directory

    @classmethod
    def from_config_file(cls, path: Path) -> "ConversionOptions":
        """Load options from a configuration file."""
        import yaml
        from m1f.file_operations import safe_open

        with safe_open(path, "r") as f:
            data = yaml.safe_load(f)

        # Handle aliases in config file
        if "source_directory" in data:
            data["source_dir"] = data.pop("source_directory")
        if "destination_directory" in data:
            data["destination_dir"] = data.pop("destination_directory")

        return cls(**data)


@dataclass
class AssetConfig:
    """Configuration for asset handling."""

    download: bool = True
    directory: Path = Path("assets")
    max_size: int = 10 * 1024 * 1024  # 10MB
    allowed_types: Set[str] = field(
        default_factory=lambda: {
            "image/jpeg",
            "image/png",
            "image/gif",
            "image/webp",
            "image/svg+xml",
            "application/pdf",
        }
    )


@dataclass
class ExtractorConfig:
    """Configuration for HTML extraction."""

    parser: str = "html.parser"  # BeautifulSoup parser
    encoding: str = "utf-8"
    decode_errors: str = "ignore"
    prettify: bool = False


@dataclass
class ProcessorConfig:
    """Configuration for Markdown processing."""

    template: Optional[Path] = None
    metadata: Dict[str, str] = field(default_factory=dict)
    frontmatter: bool = False
    toc: bool = False
    toc_depth: int = 3


@dataclass
class CrawlerConfig:
    """Configuration for web crawling."""

    max_depth: int = 1
    follow_links: bool = False
    allowed_domains: Set[str] = field(default_factory=set)
    excluded_paths: Set[str] = field(default_factory=set)
    rate_limit: float = 1.0  # seconds between requests
    timeout: int = 30
    user_agent: str = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0"
    )

    # HTTrack-specific options
    concurrent_requests: int = 4
    request_delay: float = 0.5  # seconds between requests
    respect_robots_txt: bool = True
    max_pages: int = 1000

    # Scraper backend configuration
    scraper_backend: ScraperBackend = ScraperBackend.BEAUTIFULSOUP
    scraper_config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class M1fConfig:
    """Configuration for M1F integration."""

    enabled: bool = False
    options: Dict[str, str] = field(default_factory=dict)


@dataclass
class Config:
    """Main configuration class."""

    source: Path
    destination: Path

    # Conversion options
    conversion: ConversionOptions = field(default_factory=ConversionOptions)

    # Component configs
    extractor: ExtractorConfig = field(default_factory=ExtractorConfig)
    processor: ProcessorConfig = field(default_factory=ProcessorConfig)
    assets: AssetConfig = field(default_factory=AssetConfig)
    crawler: CrawlerConfig = field(default_factory=CrawlerConfig)
    m1f: M1fConfig = field(default_factory=M1fConfig)

    # General options
    verbose: bool = False
    quiet: bool = False
    log_file: Optional[Path] = None
    dry_run: bool = False
    overwrite: bool = False

    # Processing options
    parallel: bool = False
    max_workers: int = 4
    chunk_size: int = 10

    # File handling options
    file_extensions: List[str] = field(default_factory=lambda: [".html", ".htm"])
    exclude_patterns: List[str] = field(
        default_factory=lambda: [".*", "_*", "node_modules", "__pycache__"]
    )
    target_encoding: str = "utf-8"

    # Preprocessing configuration
    preprocessing: Optional[Any] = None  # PreprocessingConfig instance

    def __post_init__(self):
        """Initialize preprocessing with defaults if not provided."""
        if self.preprocessing is None:
            from html2md_tool.preprocessors import PreprocessingConfig

            self.preprocessing = PreprocessingConfig(
                remove_elements=["script", "style", "noscript"],
                remove_empty_elements=True,
            )

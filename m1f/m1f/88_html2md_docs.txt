======= 30_html2md.md ======
# html2md (HTML to Markdown Converter)

A modern HTML to Markdown converter with HTML structure analysis, custom
extractors, async I/O, and parallel processing capabilities.

## Overview

The html2md tool (v3.4.0) provides a robust solution for converting HTML content
to Markdown format, with fine-grained control over the conversion process. Built
with Python 3.10+ and modern async architecture, it focuses on intelligent
content extraction and conversion.

**New in v3.4.0:** Custom extractor plugin system for site-specific content
extraction.

**Note:** Web scraping functionality has been moved to the separate `webscraper`
tool for better modularity. Use `webscraper` to download websites, then
`html2md` to convert the downloaded HTML files.

## Key Features

- **Custom Extractor System**: Create site-specific extractors for optimal
  content extraction
- **HTML Structure Analysis**: Analyze HTML files to find optimal content
  selectors
- **Intelligent Content Extraction**: Use CSS selectors to extract specific
  content
- **Async I/O**: High-performance concurrent file processing
- **API Mode**: Programmatic access for integration with other tools
- **Type Safety**: Full type annotations throughout the codebase
- **Modern Architecture**: Clean modular design
- **Workflow Integration**: .scrapes directory structure for organized
  processing
- Recursive directory scanning for batch conversion
- Smart internal link handling (HTML → Markdown)
- Customizable element filtering and removal
- YAML frontmatter generation
- Heading level adjustment
- Code block language detection
- Character encoding detection and conversion
- Parallel processing for faster conversion

## Quick Start

```bash
# Basic conversion of all HTML files in a directory
m1f-html2md convert ./website -o ./docs

# Use a custom extractor for site-specific conversion
m1f-html2md convert ./website -o ./docs \
  --extractor ./extractors/custom_extractor.py

# Extract only main content from HTML files
m1f-html2md convert ./website -o ./docs \
  --content-selector "main.content" --ignore-selectors nav .sidebar footer

# Skip YAML frontmatter and adjust heading levels
m1f-html2md convert ./website -o ./docs \
  --no-frontmatter --heading-offset 1

# Analyze HTML structure to find best selectors
m1f-html2md analyze ./html/*.html --suggest-selectors

# Analyze with detailed structure output
m1f-html2md analyze ./html/*.html --show-structure --common-patterns

# Use Claude AI to intelligently analyze HTML structure
m1f-html2md analyze ./html/ --claude

# Analyze with Claude and specify number of files to analyze (1-20)
m1f-html2md analyze ./html/ --claude --analyze-files 10

# Convert HTML to Markdown using Claude AI (clean content extraction)
m1f-html2md convert ./html/ -o ./markdown/ --claude --model opus --sleep 2

# Generate a configuration file
m1f-html2md config -o config.yaml
```

### Complete Workflow Example with .scrapes Directory

```bash
# Step 1: Create project structure
mkdir -p .scrapes/my-project/{html,md,extractors}

# Step 2: Download website using webscraper
m1f-scrape https://example.com -o .scrapes/my-project/html

# Step 3: Analyze HTML structure (optional)
m1f-html2md analyze .scrapes/my-project/html/ --suggest-selectors

# Step 4: Create custom extractor (optional)
# Use Claude to analyze and create site-specific extractor:
claude -p "Analyze these HTML files and create a custom extractor for html2md" \
  --files .scrapes/my-project/html/*.html

# Step 5: Convert with custom extractor
m1f-html2md convert .scrapes/my-project/html -o .scrapes/my-project/md \
  --extractor .scrapes/my-project/extractors/custom_extractor.py
```

## Command Line Interface

The html2md tool uses subcommands for different operations:

### Convert Command

Convert local HTML files to Markdown:

```bash
m1f-html2md convert <source> -o <output> [options]
```

| Option               | Description                                                   |
| -------------------- | ------------------------------------------------------------- |
| `source`             | Source file or directory                                      |
| `-o, --output`       | Output file or directory (required)                           |
| `-c, --config`       | Configuration file path (YAML format)                         |
| `--format`           | Output format: markdown, m1f_bundle, json (default: markdown) |
| `--extractor`        | Path to custom extractor Python file                          |
| `--content-selector` | CSS selector for main content                                 |
| `--ignore-selectors` | CSS selectors to ignore (space-separated)                     |
| `--heading-offset`   | Offset heading levels (default: 0)                            |
| `--no-frontmatter`   | Explicitly disable YAML frontmatter generation                |
| `--parallel`         | Enable parallel processing                                    |
| `--claude`           | Use Claude AI to convert HTML to Markdown (content only)      |
| `--model`            | Claude model to use: opus, sonnet (default: sonnet)           |
| `--sleep`            | Sleep time in seconds between Claude API calls (default: 1.0) |
| `-v, --verbose`      | Enable verbose output                                         |
| `-q, --quiet`        | Suppress all output except errors                             |

### Analyze Command

Analyze HTML structure for optimal content extraction:

```bash
m1f-html2md analyze <paths> [options]
```

| Option                | Description                                                          |
| --------------------- | -------------------------------------------------------------------- |
| `paths`               | HTML files or directories to analyze                                 |
| `--show-structure`    | Show detailed HTML structure                                         |
| `--common-patterns`   | Find common patterns across files                                    |
| `--suggest-selectors` | Suggest CSS selectors for content extraction (default if no options) |
| `--claude`            | Use Claude AI to intelligently select files and suggest selectors    |
| `--analyze-files`     | Number of files to analyze with Claude (1-20, default: 5)            |
| `-v, --verbose`       | Enable verbose output                                                |
| `-q, --quiet`         | Suppress all output except errors                                    |

### Config Command

Generate a configuration file template:

```bash
m1f-html2md config [options]
```

| Option         | Description                                            |
| -------------- | ------------------------------------------------------ |
| `-o, --output` | Output configuration file (default: config.yaml)       |
| `--format`     | Configuration format: yaml, toml, json (default: yaml) |

## Claude AI Integration

html2md offers optional Claude AI integration for intelligent HTML analysis and
conversion:

### Claude Command Detection

The tool automatically detects Claude Code installations in various locations:

- Standard PATH locations
- `~/.claude/local/claude` (common for local installations)
- `/usr/local/bin/claude` and `/usr/bin/claude`

If you have Claude Code installed but get a "command not found" error, the tool
will automatically find and use your Claude binary.

### AI-Powered Analysis

Use Claude to automatically select representative HTML files and suggest optimal
CSS selectors:

```bash
# Analyze a directory of HTML files with Claude
m1f-html2md analyze ./scraped-site/ --claude

# Analyze more files for better coverage (up to 20)
m1f-html2md analyze ./scraped-site/ --claude --analyze-files 10

# Claude will:
# 1. Prompt for project description and important files (if applicable)
# 2. Select representative files from the directory (default: 5)
# 3. Analyze each file's structure individually
# 4. Synthesize findings to suggest optimal selectors
# 5. Generate a YAML configuration (html2md_extract_config.yaml)
```

**Features of Claude Analysis:**

- **Project Context**: Provides project description to help Claude understand
  the content
- **Important File Priority**: Can specify important files for Claude to
  prioritize
- **Multi-phase Analysis**: Individual file analysis followed by synthesis
- **Transparent Process**: Creates temporary analysis files in m1f/ directory
- **Smart Subprocess Handling**: Uses subprocess.run() for reliable Claude CLI
  integration
- **Streaming Output**: Real-time progress display during Claude analysis
  (v3.4.0)
- **Robust Config Loading**: Handles Claude-generated configs with unknown
  fields gracefully (v3.4.0)

### AI-Powered Conversion

Use Claude to convert HTML to clean Markdown, extracting only the main content:

```bash
# Convert all HTML files using Claude AI
m1f-html2md convert ./html/ -o ./markdown/ --claude

# Use Opus model for higher quality (default is Sonnet)
m1f-html2md convert ./html/ -o ./markdown/ --claude --model opus

# Add delay between API calls to avoid rate limits
m1f-html2md convert ./html/ -o ./markdown/ --claude --sleep 3
```

The Claude conversion:

- Extracts only the main content (no navigation, ads, etc.)
- Preserves document structure and formatting
- Handles complex HTML layouts intelligently
- Generates clean, readable Markdown

## Usage Examples

### Basic Conversion

```bash
# Simple conversion of all HTML files in a directory
m1f-html2md convert ./website -o ./docs

# Convert files with verbose logging
m1f-html2md convert ./website -o ./docs --verbose

# Convert to m1f bundle format
m1f-html2md convert ./website -o ./docs.m1f --format m1f_bundle

# Convert to JSON format for processing
m1f-html2md convert ./website -o ./data.json --format json
```

### Content Selection

```bash
# Extract only the main content and ignore navigation elements
m1f-html2md convert ./website -o ./docs \
  --content-selector "main" --ignore-selectors nav .sidebar footer

# Extract article content from specific selectors
m1f-html2md convert ./website -o ./docs \
  --content-selector "article.content" \
  --ignore-selectors .author-bio .share-buttons .related-articles
```

### HTML Analysis

```bash
# Analyze HTML files to find optimal selectors
m1f-html2md analyze ./html/ --suggest-selectors

# Show detailed structure of HTML files
m1f-html2md analyze ./html/ --show-structure

# Find common patterns across multiple files
m1f-html2md analyze ./html/ --common-patterns

# Get all analysis options
m1f-html2md analyze ./html/ \
  --show-structure --common-patterns --suggest-selectors
```

### File Filtering

```bash
# Process only specific file types
m1f-html2md convert ./website -o ./docs \
  -c config.yaml  # Use a configuration file for file filtering
```

### Formatting Options

```bash
# Adjust heading levels (e.g., h1 → h2, h2 → h3)
m1f-html2md convert ./website -o ./docs \
  --heading-offset 1

# Skip frontmatter generation
m1f-html2md convert ./website -o ./docs \
  --no-frontmatter

# Use configuration file for advanced formatting options
m1f-html2md convert ./website -o ./docs -c config.yaml

# Log conversion process to file
m1f-html2md convert ./website -o ./docs \
  --log-file conversion.log
```

### Performance Optimization

```bash
# Use parallel processing for faster conversion of large sites
m1f-html2md convert ./website -o ./docs \
  --parallel
```

## Custom Extractors

The custom extractor system allows you to create site-specific content
extraction logic for optimal results. Extractors can be simple functions or full
classes.

### Creating a Custom Extractor

#### Function-based Extractor

```python
# extractors/simple_extractor.py
from bs4 import BeautifulSoup
from typing import Optional, Dict, Any

def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    """Extract main content from HTML."""
    # Remove navigation elements
    for nav in soup.find_all(['nav', 'header', 'footer']):
        nav.decompose()

    # Find main content
    main = soup.find('main') or soup.find('article')
    if main:
        new_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
        new_soup.body.append(main)
        return new_soup

    return soup

def postprocess(markdown: str, config: Optional[Dict[str, Any]] = None) -> str:
    """Clean up the converted markdown."""
    # Remove duplicate newlines
    import re
    return re.sub(r'\n{3,}', '\n\n', markdown)
```

#### Class-based Extractor

```python
# extractors/advanced_extractor.py
from tools.html2md.extractors import BaseExtractor
from bs4 import BeautifulSoup
from typing import Optional, Dict, Any

class Extractor(BaseExtractor):
    """Custom extractor for specific website."""

    def extract(self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
        """Extract content with site-specific logic."""
        # Custom extraction logic
        return soup

    def preprocess(self, html: str, config: Optional[Dict[str, Any]] = None) -> str:
        """Preprocess raw HTML before parsing."""
        # Fix common HTML issues
        return html.replace('&nbsp;', ' ')

    def postprocess(self, markdown: str, config: Optional[Dict[str, Any]] = None) -> str:
        """Post-process converted markdown."""
        # Clean up site-specific artifacts
        return markdown
```

### Using Custom Extractors

```bash
# Use with CLI
m1f-html2md convert ./html -o ./markdown \
  --extractor ./extractors/my_extractor.py

# Use with API
from tools.html2md.api import Html2mdConverter
from pathlib import Path

converter = Html2mdConverter(
    config,
    extractor=Path("./extractors/my_extractor.py")
)
```

### .scrapes Directory Structure

The recommended workflow uses a `.scrapes` directory (gitignored) for organizing
scraping projects:

```
.scrapes/
└── project-name/
    ├── html/         # Raw HTML files from scraping
    ├── md/           # Converted Markdown files
    └── extractors/   # Custom extraction scripts
        └── custom_extractor.py
```

This structure keeps scraped content organized and separate from your main
codebase.

## Advanced Features

### YAML Frontmatter

By default, the converter does NOT add YAML frontmatter to Markdown files.
The output contains only the converted content without any metadata.

To enable frontmatter generation (which includes title extraction from HTML),
use the `generate_frontmatter: true` option in your config file:

```yaml
# config.yaml
conversion:
  generate_frontmatter: true  # Enable frontmatter

# Then use:
m1f-html2md convert ./website -o ./docs -c config.yaml
```

When enabled, the generated frontmatter contains only the title:

```yaml
---
title: Extracted from HTML
---
```

To explicitly disable frontmatter (overrides config file), use:

```bash
m1f-html2md convert ./website -o ./docs --no-frontmatter
```

Note: The `source_file` field has been removed from frontmatter generation to 
avoid exposing file paths.

### Heading Level Adjustment

The `--heading-offset` option allows you to adjust the hierarchical structure of
the document by incrementing or decrementing heading levels. This is useful
when:

- Integrating content into an existing document with its own heading hierarchy
- Making h1 headings become h2 headings for better document structure
- Ensuring proper nesting of headings for better semantics

Positive values increase heading levels (e.g., h1 → h2), while negative values
decrease them (e.g., h2 → h1).

### Code Block Language Detection

The converter can automatically detect language hints from HTML code blocks that
use language classes, such as:

```html
<pre><code class="language-python">def example():
    return "Hello, world!"
</code></pre>
```

This will be converted to a properly formatted Markdown code block with language
hint:

````markdown
```python
def example():
    return "Hello, world!"
```
````

### Character Encoding Handling

The converter provides robust character encoding detection and conversion:

1. Automatically detects the encoding of source HTML files
2. Properly handles UTF-8, UTF-16, and other encodings
3. All output files are written in UTF-8 encoding
4. Handles BOM (Byte Order Mark) detection for Unicode files

## Architecture

HTML2MD v3.4.0 features a modern, modular architecture:

```
tools/html2md/
├── __init__.py       # Package initialization
├── __main__.py       # Entry point for module execution
├── api.py            # Programmatic API for other tools
├── cli.py            # Command-line interface
├── config/           # Configuration management
│   ├── __init__.py
│   ├── loader.py     # Config file loader
│   └── models.py     # Config data models
├── core.py           # Core conversion logic
├── extractors.py     # Custom extractor system
├── preprocessors.py  # HTML preprocessing
├── analyze_html.py   # HTML structure analysis
└── utils.py          # Utility functions

.scrapes/             # Project scrapes directory (gitignored)
└── project-name/
    ├── html/         # Raw HTML files
    ├── md/           # Converted Markdown
    └── extractors/   # Custom extractors
```

### Key Components

- **API Mode**: Use as a library in other Python projects
- **Custom Extractors**: Pluggable extractor system for site-specific logic
- **Type Safety**: Full type hints and dataclass models
- **Clean Architecture**: Separation of concerns with dependency injection
- **Async Support**: Modern async/await for high performance
- **Workflow Integration**: Organized .scrapes directory structure

## Integration with m1f

The html2md tool works well with the m1f (Make One File) tool for comprehensive
documentation handling:

1. First convert HTML files to Markdown:

   ```bash
   m1f-html2md convert ./html-docs -o ./markdown-docs
   ```

2. Then use m1f to combine the Markdown files:
   ```bash
   m1f -s ./markdown-docs -o ./combined-docs.m1f.txt \
     --separator-style Markdown
   ```

This workflow is ideal for:

- Converting documentation from HTML to Markdown format
- Consolidating documentation from multiple sources
- Preparing content for LLM context windows
- Creating searchable knowledge bases

## Performance Considerations

- For large websites with many HTML files, use the `--parallel` option
- Conversion speed depends on file size, complexity, and number of files
- Memory usage scales with file sizes when parallel processing is enabled
- The tool uses async I/O for efficient file operations

## Programmatic API

Use html2md in your Python projects:

```python
from tools.html2md.api import Html2mdConverter
from tools.html2md.config import Config
from tools.html2md.extractors import BaseExtractor
from tools.shared.colors import info, success
from pathlib import Path

# Create converter with configuration
config = Config(
    source=Path("./html"),
    destination=Path("./markdown")
)
converter = Html2mdConverter(config)

# Convert with custom extractor
converter = Html2mdConverter(
    config,
    extractor=Path("./extractors/custom_extractor.py")
)

# Or with inline extractor
class MyExtractor(BaseExtractor):
    def extract(self, soup, config=None):
        # Custom logic
        return soup

converter = Html2mdConverter(config, extractor=MyExtractor())

# Convert a single file
output_path = converter.convert_file(Path("page.html"))
success(f"Converted to: {output_path}")

# Convert entire directory
results = converter.convert_directory()
info(f"Converted {len(results)} files")
```

## Requirements and Dependencies

- Python 3.10 or newer
- Required packages:
  - beautifulsoup4: For HTML parsing
  - markdownify: For HTML to Markdown conversion
  - aiofiles: For async file operations
  - rich: For console output
  - pydantic: For configuration models
- Optional packages:
  - chardet: For encoding detection
  - pyyaml: For YAML configuration files
  - toml: For TOML configuration files

Install dependencies:

```bash
pip install beautifulsoup4 markdownify chardet pyyaml aiofiles rich pydantic
```

**Note**: For web scraping functionality, use the separate `webscraper` tool
which provides multiple backend options including HTTrack.

======= 31_html2md_guide.md ======
# HTML to Markdown Converter Guide

The `html2md` tool (v3.1.0) is a modern, async converter designed to transform
HTML content into clean Markdown format. Built with Python 3.10+ and modern
async architecture, it focuses on intelligent content extraction and conversion.

**Note:** Web scraping functionality has been moved to the separate `webscraper`
tool. Use `webscraper` to download websites, then `html2md` to convert the
downloaded HTML files.

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Command Line Usage](#command-line-usage)
- [Configuration](#configuration)
- [Python API](#python-api)
- [Custom Extractors](#custom-extractors)
- [Advanced Features](#advanced-features)
- [Examples](#examples)
- [Troubleshooting](#troubleshooting)

## Installation

### Python Dependencies

```bash
pip install beautifulsoup4 markdownify pydantic rich httpx chardet pyyaml aiofiles

# Optional dependencies
pip install toml      # For TOML configuration files
```

### Installation

```bash
pip install beautifulsoup4 markdownify pydantic rich chardet pyyaml aiofiles

# Optional dependencies
pip install toml      # For TOML configuration files
```

## Quick Start

### Convert a Single File

```bash
m1f-html2md convert index.html -o index.md
```

### Convert a Directory

```bash
m1f-html2md convert ./html_docs/ -o ./markdown_docs/
```

### Analyze HTML Structure

```bash
m1f-html2md analyze ./html/*.html --suggest-selectors
```

### Generate Configuration

```bash
m1f-html2md config -o config.yaml
```

## Command Line Usage

The tool provides three main commands with beautifully formatted help output:

- **Colored Output**: Uses colorama for colored help text and error messages
- **Organized Parameters**: Arguments grouped by functionality
- **Consistent Style**: Matches the m1f tool's help formatting

### Global Options

```bash
m1f-html2md [options] COMMAND ...

Options:
  -h, --help           Show help message and exit
  --version            Show program version and exit

Output Control:
  -v, --verbose        Enable verbose output
  -q, --quiet          Suppress all output except errors
  --log-file LOG_FILE  Write logs to file
```

### `convert` - Convert Files or Directories

```bash
m1f-html2md convert [source] -o [output] [options]

Positional Arguments:
  source                Source HTML file or directory
  -o, --output          Output file or directory (required)

Configuration:
  -c, --config          Configuration file (YAML/JSON/TOML)
  --format              Output format (markdown, m1f_bundle, json)
                        Default: markdown

Content Extraction:
  --content-selector    CSS selector for main content area
  --ignore-selectors    CSS selectors to ignore (nav, header, footer, etc.)
  --extractor          Path to custom extractor Python file

Processing Options:
  --heading-offset     Offset heading levels by N (default: 0)
  --no-frontmatter     Don't add YAML frontmatter to output
  --parallel           Enable parallel processing for multiple files

Claude AI Options:
  --claude             Use Claude AI for intelligent HTML to Markdown conversion
  --model              Claude model to use (opus, sonnet) Default: sonnet
  --sleep              Delay between Claude API calls in seconds (default: 1.0)
```

### `analyze` - Analyze HTML Structure

```bash
m1f-html2md analyze [paths] [options]

Positional Arguments:
  paths                HTML files or directories to analyze

Analysis Options:
  --show-structure     Show detailed HTML structure analysis
  --common-patterns    Find common patterns across multiple files
  --suggest-selectors  Suggest CSS selectors for content extraction

Claude AI Options:
  --claude             Use Claude AI for intelligent analysis and selector suggestions
  --analyze-files      Number of files to analyze with Claude (1-20, default: 5)
  --parallel-workers   Number of parallel Claude sessions (1-10, default: 5)
  --project-description Project description for Claude context
```

### `config` - Generate Configuration File

```bash
m1f-html2md config [options]

Configuration Options:
  -o, --output         Output configuration file (default: config.yaml)
  --format             Configuration file format (yaml, toml, json)
                       Default: yaml
```

## Configuration

### Configuration File Structure

Create a `config.yaml` file:

```yaml
# Basic settings (v3.1.0 format)
source: ./html_docs
destination: ./markdown_docs
output_format: markdown

# Content extraction
extractor:
  content_selector: "article.content, main, .documentation"
  ignore_selectors:
    - nav
    - header
    - footer
    - .sidebar
    - .ads
    - "#comments"
  remove_elements:
    - script
    - style
    - iframe
  extract_metadata: true
  extract_opengraph: true

# Markdown processing
processor:
  heading_offset: 0
  add_frontmatter: true
  heading_style: atx
  link_handling: convert
  link_extensions:
    .html: .md
    .htm: .md
  normalize_whitespace: true
  fix_encoding: true

# Parallel processing
parallel: true

# Logging
verbose: false
quiet: false
log_file: ./conversion.log
```

### Configuration Options Explained

#### Extractor Configuration

- `content_selector`: CSS selector(s) to find main content
- `ignore_selectors`: Elements to remove before conversion
- `remove_elements`: HTML tags to completely remove
- `preserve_attributes`: HTML attributes to keep
- `extract_metadata`: Extract meta tags and title
- `extract_opengraph`: Extract OpenGraph metadata

#### Processor Configuration

- `heading_offset`: Adjust heading levels (e.g., h1→h2)
- `link_handling`: How to process links (convert/preserve/absolute/relative)
- `normalize_whitespace`: Clean up extra whitespace
- `fix_encoding`: Fix common encoding issues

#### Processing Configuration

- `parallel`: Enable parallel processing for multiple files
- `verbose`: Enable verbose logging
- `quiet`: Suppress all output except errors
- `log_file`: Path to log file

## Python API

### Basic Usage

```python
from tools.html2md.api import HTML2MDConverter
import asyncio

# Create converter with configuration
converter = HTML2MDConverter(
    outermost_selector="main",
    ignore_selectors=["nav", "footer"],
    add_frontmatter=True
)

# Convert a directory (async)
results = asyncio.run(converter.convert_directory("./html", "./markdown"))

# Convert a single file (async)
result = asyncio.run(converter.convert_file("index.html"))

# Convert with custom extractor
from pathlib import Path

converter = HTML2MDConverter(
    outermost_selector="main",
    extractor=Path("./extractors/custom_extractor.py")
)

result = asyncio.run(converter.convert_file("index.html"))
```

### Advanced Configuration

```python
from tools.html2md.config.models import HTML2MDConfig

# Create configuration with v3.1.0 models
config = HTML2MDConfig(
    source_dir="./html",
    destination_dir="./output",
    outermost_selector="div.documentation",
    ignore_selectors=[".nav-menu", ".footer"],
    strip_attributes=True,
    heading_offset=1,
    add_frontmatter=True,
    parallel=True,
    max_workers=4
)

converter = HTML2MDConverter.from_config(config)
```

### Convenience Functions

```python
from tools.html2md.api import convert_file, convert_directory
import asyncio

# Simple file conversion (async)
result = asyncio.run(convert_file("page.html", destination="page.md"))

# Directory conversion with options (async)
results = asyncio.run(convert_directory(
    source="./html",
    destination="./markdown",
    outermost_selector="article",
    parallel=True
))
```

## Custom Extractors

The custom extractor system allows you to create site-specific content
extraction logic:

### Function-based Extractor

```python
# extractors/my_extractor.py
from bs4 import BeautifulSoup

def extract(soup: BeautifulSoup, config=None):
    """Extract main content."""
    # Custom extraction logic
    main = soup.find('main')
    if main:
        new_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
        new_soup.body.append(main)
        return new_soup
    return soup

def postprocess(markdown: str, config=None):
    """Clean up converted markdown."""
    import re
    return re.sub(r'\n{3,}', '\n\n', markdown)
```

### Using Custom Extractors

```bash
m1f-html2md convert ./html -o ./markdown \
  --extractor ./extractors/my_extractor.py
```

## Advanced Features

### Content Extraction with CSS Selectors

Target specific content areas:

```yaml
extractor:
  content_selector: |
    article.post-content,
    div.documentation-body,
    main[role="main"],
    #content:not(.sidebar)
```

### Link Handling Strategies

1. **Convert**: Change `.html` to `.md`

   ```yaml
   processor:
     link_handling: convert
     link_extensions:
       .html: .md
       .php: .md
   ```

2. **Preserve**: Keep original links

   ```yaml
   processor:
     link_handling: preserve
   ```

3. **Absolute**: Make all links absolute
   ```yaml
   processor:
     link_handling: absolute
   ```

### Metadata Extraction

The tool can extract and preserve:

- Page title
- Meta description
- OpenGraph data
- Schema.org structured data
- Custom meta tags

### m1f Bundle Creation

Generate m1f bundles directly:

```yaml
output_format: m1f_bundle
m1f:
  create_bundle: true
  bundle_name: my-documentation
  include_assets: true
  generate_index: true
  metadata:
    project: My Project Docs
    version: 1.0.0
```

## Examples

### Example 1: Convert Documentation Site

```bash
# Create configuration
cat > docs-config.yaml << EOF
source: ./python-docs-html
destination: ./python-docs-md
extractor:
  content_selector: "div.document"
  ignore_selectors:
    - ".sphinxsidebar"
    - ".related"
processor:
  heading_offset: 1
  add_frontmatter: true
parallel: true
EOF

# Run conversion
m1f-html2md convert ./python-docs-html -o ./python-docs-md -c docs-config.yaml
```

### Example 2: Convert Blog with Specific Content

```python
from tools.html2md.api import HTML2MDConverter
import asyncio

converter = HTML2MDConverter(
    outermost_selector="article.post",
    ignore_selectors=[
        ".post-navigation",
        ".comments-section",
        ".social-share"
    ],
    add_frontmatter=True,
    heading_offset=0
)

# Convert all blog posts (async)
results = asyncio.run(converter.convert_directory(
    "./blog-html",
    "./blog-markdown"
))
```

### Example 3: Create m1f Bundle from HTML

```bash
# First download the website using webscraper
m1f-scrape https://docs.example.com -o ./html

# Then convert to m1f bundle
m1f-html2md convert ./html \
  -o ./output.m1f \
  --format m1f_bundle \
  --content-selector "main.content" \
  --ignore-selectors nav footer
```

### Example 4: Claude Code Documentation Bundle

A complete example for scraping Claude Code documentation is available in `examples/claude_code_doc/`:

```bash
# Fast mode with existing config (saves 5-8 minutes!)
source .venv/bin/activate
python examples/claude_code_doc/scrape_claude_code_docs.py ~/claude-docs \
    --use-config examples/claude_code_doc/html2md_claude_code_doc.config.yml

# Or let Claude AI analyze and create config automatically
python examples/claude_code_doc/scrape_claude_code_docs.py ~/claude-docs
```

This example:
- Scrapes ~31 HTML pages from docs.anthropic.com/claude-code
- Uses optimized config or Claude AI analysis for content extraction
- Creates clean Markdown documentation bundle
- Supports both fast mode (with config) and full analysis mode

See `examples/claude_code_doc/README.md` for details.

### Example 5: Tailscale Documentation Bundle

A complete example for scraping and bundling documentation is available in `examples/tailscale_doc/`:

```bash
# Download ~422 HTML files and create 11 thematic bundles
python examples/tailscale_doc/scrape_tailscale_docs.py ~/tailscale-docs

# Or skip download if HTML already exists
python examples/tailscale_doc/scrape_tailscale_docs.py ~/tailscale-docs --skip-download
```

This example demonstrates:
- Scraping ~422 HTML pages with respectful delays
- Converting HTML to Markdown with optimized selectors
- Creating 11 thematic bundles (2.4MB total):
  - Complete documentation bundle
  - Getting started guide (27KB)
  - Platform installations (374KB)  
  - Networking & DNS (200KB)
  - Authentication & Security (418KB)
  - And 6 more specialized bundles

The configuration files showcase:
- Custom HTML extraction selectors for Tailscale's documentation structure
- Intelligent bundle organization for LLM consumption
- Parallel processing for faster conversion

See `examples/tailscale_doc/README.md` for full details.

## Troubleshooting

### Common Issues

1. **Content selector not matching**

   ```
   WARNING: Content selector 'article' not found
   ```

   Solution: Use the analyze command to find the right selectors:

   ```bash
   m1f-html2md analyze ./html/*.html --suggest-selectors
   ```

2. **Encoding issues**

   ```
   UnicodeDecodeError: 'utf-8' codec can't decode
   ```

   Solution: The tool auto-detects encoding, but HTML files may have mixed
   encodings. All output is converted to UTF-8.

3. **Large directories timing out**

   Solution: Use parallel processing:

   ```bash
   m1f-html2md convert ./html -o ./md --parallel
   ```

4. **Missing content after conversion**

   Solution: Check your ignore selectors - they may be too broad:

   ```bash
   m1f-html2md convert ./html -o ./md \
     --content-selector "body" \
     --ignore-selectors .ads .cookie-notice
   ```

### Debug Mode

Enable verbose logging for debugging:

```bash
m1f-html2md convert ./html -o ./md -v --log-file debug.log
```

Or in configuration:

```yaml
verbose: true
log_file: ./conversion-debug.log
```

### Performance Tips

1. **Use parallel processing** for large directories:

   ```yaml
   parallel: true
   ```

2. **Target specific content** to reduce processing:

   ```yaml
   extractor:
     content_selector: "article.documentation"
   ```

3. **Use custom extractors** for complex sites to optimize extraction

## Integration with m1f

The converted Markdown files are optimized for m1f bundling:

1. Clean, consistent formatting
2. Preserved metadata in frontmatter
3. Proper link structure
4. UTF-8 encoding

To create an m1f bundle after conversion:

```bash
# Download website first
m1f-scrape https://docs.example.com -o ./html/

# Convert to Markdown
m1f-html2md convert ./html/ -o ./docs/

# Create m1f bundle
m1f -s ./docs/ -o documentation.m1f.txt
```

Or convert directly to m1f bundle format:

```bash
m1f-html2md convert ./html/ \
  -o ./docs.m1f \
  --format m1f_bundle
```

======= 32_html2md_workflow_guide.md ======
# HTML2MD Workflow Guide

This guide explains the recommended workflow for converting websites to Markdown
using html2md with custom extractors.

## Overview

The html2md tool now supports a flexible workflow that separates concerns:

1. HTML acquisition (scraping or external)
2. Content analysis and extractor development
3. Conversion with site-specific extraction

## Directory Structure

All scraping projects use the `.scrapes` directory (gitignored):

```
.scrapes/
└── project-name/
    ├── html/         # Raw HTML files
    ├── md/           # Converted Markdown files
    └── extractors/   # Custom extraction scripts
```

## Complete Workflow

### Step 1: Set Up Project Structure

```bash
# Create project directories
mkdir -p .scrapes/my-docs/{html,md,extractors}
```

### Step 2: Acquire HTML Content

You have several options:

#### Option A: Use webscraper tool

```bash
m1f-scrape https://example.com \
  -o .scrapes/my-docs/html \
  --max-pages 50 \
  --scraper playwright
```

#### Option B: Manual download

- Save HTML files directly to `.scrapes/my-docs/html/`
- Use browser "Save As" or wget/curl
- Any method that gets HTML files

#### Option C: External scraping

- Use any scraping tool you prefer
- Just ensure HTML files end up in the html/ directory

### Step 3: Analyze HTML Structure (Optional)

Understand the HTML structure before creating extractors:

```bash
# Analyze a few sample files
m1f-html2md analyze \
  .scrapes/my-docs/html/*.html \
  --suggest-selectors

# Get detailed structure analysis
m1f-html2md analyze \
  .scrapes/my-docs/html/*.html \
  --show-structure \
  --common-patterns
```

### Step 4: Create Custom Extractor (Optional)

#### Manual Creation

Create `.scrapes/my-docs/extractors/custom_extractor.py`:

```python
from bs4 import BeautifulSoup
from typing import Optional, Dict, Any

def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    """Extract main content from HTML."""
    # Remove site-specific navigation
    for selector in ['nav', '.sidebar', '#header', '#footer']:
        for elem in soup.select(selector):
            elem.decompose()

    # Find main content area
    main = soup.find('main') or soup.find('article') or soup.find('.content')
    if main:
        # Create clean soup with just main content
        new_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
        new_soup.body.append(main)
        return new_soup

    return soup

def postprocess(markdown: str, config: Optional[Dict[str, Any]] = None) -> str:
    """Clean up converted markdown."""
    lines = markdown.split('\n')
    cleaned = []

    for line in lines:
        # Remove "Copy" buttons before code blocks
        if line.strip() == 'Copy':
            continue
        cleaned.append(line)

    return '\n'.join(cleaned)
```

#### Claude-Assisted Creation

Use Claude to analyze HTML and create a custom extractor:

```bash
# Have Claude analyze the HTML structure
claude -p "Analyze these HTML files and create a custom extractor for html2md. \
The extractor should:
1. Remove all navigation, headers, footers, and sidebars
2. Extract only the main content
3. Clean up any site-specific artifacts in the markdown
4. Handle the specific structure of this website

Write the extractor to .scrapes/my-docs/extractors/custom_extractor.py" \
--files .scrapes/my-docs/html/*.html
```

### Step 5: Convert HTML to Markdown

#### With Custom Extractor

```bash
cd .scrapes/my-docs
m1f-html2md convert html -o md \
  --extractor extractors/custom_extractor.py
```

#### With Default Extractor

```bash
cd .scrapes/my-docs
m1f-html2md convert html -o md
```

#### With CSS Selectors Only

```bash
cd .scrapes/my-docs
m1f-html2md convert html -o md \
  --content-selector "main.content" \
  --ignore-selectors "nav" ".sidebar" ".ads"
```

### Step 6: Review and Refine

1. Check the converted Markdown files
2. If quality needs improvement:
   - Update the custom extractor
   - Re-run the conversion
   - Iterate until satisfied

## Example: Documentation Site

Here's a complete example for converting a documentation site:

```bash
# 1. Setup
mkdir -p .scrapes/docs-site/{html,md,extractors}

# 2. Download documentation
m1f-scrape https://docs.example.com \
  -o .scrapes/docs-site/html \
  --max-pages 100 \
  --scraper playwright

# 3. Analyze structure
m1f-html2md analyze \
  .scrapes/docs-site/html/*.html \
  --suggest-selectors

# 4. Create extractor for docs site
cat > .scrapes/docs-site/extractors/docs_extractor.py << 'EOF'
from bs4 import BeautifulSoup
from typing import Optional, Dict, Any

def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    # Remove docs-specific elements
    for selector in [
        '.docs-nav', '.docs-sidebar', '.docs-header',
        '.docs-footer', '.edit-page', '.feedback',
        '[class*="navigation"]', '[id*="toc"]'
    ]:
        for elem in soup.select(selector):
            elem.decompose()

    # Extract article content
    article = soup.find('article') or soup.find('.docs-content')
    if article:
        new_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
        new_soup.body.append(article)
        return new_soup

    return soup

def postprocess(markdown: str, config: Optional[Dict[str, Any]] = None) -> str:
    # Clean up docs-specific patterns
    import re

    # Remove "Copy" buttons
    markdown = re.sub(r'^Copy\s*\n', '', markdown, flags=re.MULTILINE)

    # Remove "On this page" sections
    markdown = re.sub(r'^On this page.*?(?=^#|\Z)', '', markdown,
                      flags=re.MULTILINE | re.DOTALL)

    return markdown.strip()
EOF

# 5. Convert with custom extractor
cd .scrapes/docs-site
m1f-html2md convert html -o md \
  --extractor extractors/docs_extractor.py

# 6. Create m1f bundle (optional)
m1f -s md -o docs-bundle.txt
```

## Best Practices

### 1. Start Small

- Test with a few HTML files first
- Refine the extractor before processing everything

### 2. Iterative Development

- Create basic extractor
- Convert a sample
- Identify issues
- Update extractor
- Repeat until satisfied

### 3. Extractor Tips

- Use specific CSS selectors for the site
- Remove navigation early in extraction
- Handle site-specific patterns in postprocess
- Test with different page types

### 4. Organization

- Keep each project in its own directory
- Document site-specific quirks
- Save working extractors for reuse

### 5. Performance

- Use `--parallel` for large conversions
- Process in batches if needed
- Monitor memory usage

## Troubleshooting

### Common Issues

**Issue**: Navigation elements still appear in Markdown

- **Solution**: Add more specific selectors to the extractor
- Check for dynamic class names or IDs

**Issue**: Missing content

- **Solution**: Verify content selector is correct
- Check if content is loaded dynamically (use playwright scraper)

**Issue**: Broken formatting

- **Solution**: Adjust extraction logic
- Use postprocess to fix patterns

**Issue**: Encoding errors

- **Solution**: Ensure HTML files are UTF-8
- Use `--target-encoding utf-8` if needed

### Debug Tips

1. **Test extractor standalone**:

```python
from bs4 import BeautifulSoup
from pathlib import Path
from tools.shared.colors import info

# Load your extractor
import sys
sys.path.append('.scrapes/my-docs/extractors')
import custom_extractor

# Test on single file
html = Path('.scrapes/my-docs/html/sample.html').read_text()
soup = BeautifulSoup(html, 'html.parser')
result = custom_extractor.extract(soup)
info(result.prettify())
```

2. **Use verbose mode**:

```bash
m1f-html2md convert html -o md \
  --extractor extractors/custom_extractor.py \
  --verbose
```

3. **Process single file**:

```bash
m1f-html2md convert html/single-file.html \
  -o test.md \
  --extractor extractors/custom_extractor.py
```

## Advanced Techniques

### Multi-Stage Extraction

For complex sites, use multiple extraction stages:

```python
def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    # Stage 1: Remove obvious non-content
    remove_selectors = ['script', 'style', 'nav', 'header', 'footer']
    for selector in remove_selectors:
        for elem in soup.select(selector):
            elem.decompose()

    # Stage 2: Find content container
    container = soup.select_one('.main-container') or soup.body

    # Stage 3: Clean within container
    for elem in container.select('.ads, .social-share, .related'):
        elem.decompose()

    # Stage 4: Extract final content
    content = container.select_one('article') or container

    new_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
    new_soup.body.append(content)
    return new_soup
```

### Conditional Extraction

Handle different page types:

```python
def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    # Detect page type
    if soup.find('article', class_='blog-post'):
        return extract_blog_post(soup)
    elif soup.find('div', class_='documentation'):
        return extract_documentation(soup)
    elif soup.find('div', class_='api-reference'):
        return extract_api_reference(soup)
    else:
        return extract_generic(soup)
```

### Metadata Preservation

Keep important metadata:

```python
def extract(soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None) -> BeautifulSoup:
    # Preserve title
    title = soup.find('title')

    # Extract content
    content = soup.find('main')

    # Create new soup with metadata
    new_soup = BeautifulSoup('<html><head></head><body></body></html>', 'html.parser')
    if title:
        new_soup.head.append(title)
    if content:
        new_soup.body.append(content)

    return new_soup
```

## Conclusion

The html2md workflow provides maximum flexibility:

- Separate HTML acquisition from conversion
- Site-specific extractors for optimal results
- Iterative refinement process
- Integration with other tools (webscraper, m1f)

This approach ensures you can handle any website structure and produce clean,
readable Markdown output.

======= 33_html2md_test_suite.md ======
# HTML2MD Test Suite Documentation

A comprehensive test suite for validating the html2md converter (v2.0.0) with
challenging real-world HTML structures.

## Overview

The HTML2MD test suite provides a robust testing framework consisting of:

- A Flask-based web server serving complex HTML test pages
- Comprehensive pytest test cases covering all conversion features including
  async operations
- Real-world documentation examples with challenging HTML structures
- Automated test runner with coverage reporting
- Full support for testing async/await patterns and parallel processing

## Architecture

```
tests/
├── html2md_server/
│   ├── server.py              # Flask test server
│   ├── requirements.txt       # Test suite dependencies
│   ├── run_tests.sh          # Automated test runner
│   ├── README.md             # Test suite documentation
│   ├── static/
│   │   ├── css/
│   │   │   └── modern.css    # Modern CSS with dark mode
│   │   └── js/
│   │       └── main.js       # Interactive features
│   └── test_pages/
│       ├── index.html        # Test suite homepage
│       ├── m1f-documentation.html
│       ├── html2md-documentation.html
│       ├── complex-layout.html
│       ├── code-examples.html
│       └── ...               # Additional test pages
└── test_html2md_server.py    # Pytest test cases
```

## Test Server

### Features

- Modern Flask-based web server
- RESTful API endpoints for test page discovery
- CORS enabled for cross-origin testing
- Dynamic page generation support
- Static asset serving with proper MIME types

### Running the Server

```bash
# Start server on default port 8080
python tests/html2md_server/server.py

# Server provides:
# - http://localhost:8080/            # Test suite homepage
# - http://localhost:8080/page/{name} # Individual test pages
# - http://localhost:8080/api/test-pages # JSON API
```

## Test Pages

### 1. M1F Documentation (`m1f-documentation.html`)

Tests real documentation conversion with:

- Complex heading hierarchies
- Code examples in multiple languages
- Nested structures and feature grids
- Command-line documentation tables
- Advanced layout with inline styles

### 2. HTML2MD Documentation (`html2md-documentation.html`)

Comprehensive documentation page testing:

- Multi-level navigation structures
- API documentation with code examples
- Complex tables and option grids
- Details/Summary elements
- Sidebar navigation

### 3. Complex Layout Test (`complex-layout.html`)

CSS layout challenges:

- **Flexbox layouts**: Multi-item flex containers
- **CSS Grid**: Complex grid with spanning items
- **Nested structures**: Up to 4 levels deep
- **Positioning**: Absolute, relative, sticky elements
- **Multi-column layouts**: CSS columns with rules
- **Masonry layouts**: Pinterest-style card layouts
- **Overflow containers**: Scrollable areas

### 4. Code Examples Test (`code-examples.html`)

Programming language support:

- **Languages tested**: Python, TypeScript, JavaScript, Bash, SQL, Go, Rust
- **Inline code**: Mixed with regular text
- **Code with special characters**: HTML entities, Unicode
- **Configuration files**: YAML, JSON examples
- **Edge cases**: Empty blocks, long lines, whitespace-only

### 5. Additional Test Pages (Planned)

- **Edge Cases**: Malformed HTML, special characters
- **Modern Features**: HTML5 elements, web components
- **Tables and Lists**: Complex nested structures
- **Multimedia**: Images, videos, iframes

## Test Suite Features

### Content Selection Testing

```python
# Test CSS selector-based extraction (v2.0.0 async API)
from tools.html2md.api import HTML2MDConverter
import asyncio

converter = HTML2MDConverter(
    outermost_selector="article",
    ignore_selectors=["nav", ".sidebar", "footer"]
)

# Async conversion
result = asyncio.run(converter.convert_file("test.html"))
```

### Code Block Detection

- Automatic language detection from class names
- Preservation of syntax highlighting hints
- Special character handling in code

### Layout Preservation

- Nested structure maintenance
- List hierarchy preservation
- Table structure conversion
- Heading level consistency

### Edge Case Handling

- Empty HTML documents
- Malformed HTML structures
- Very long lines
- Unicode and special characters
- Missing closing tags

## Running Tests

### Quick Start

```bash
# Run all tests with the automated script
./tests/html2md_server/run_tests.sh

# This will:
# 1. Install dependencies
# 2. Start the test server
# 3. Run all pytest tests
# 4. Generate coverage report
# 5. Clean up processes
```

### Manual Testing

```bash
# Install dependencies
pip install -r tests/html2md_server/requirements.txt

# Start server in one terminal
python tests/html2md_server/server.py

# Run tests in another terminal
pytest tests/test_html2md_server.py -v

# Run with coverage
pytest tests/test_html2md_server.py --cov=tools.html2md_tool --cov-report=html
```

### Test Options

```bash
# Run specific test
pytest tests/test_html2md_server.py::TestHTML2MDConversion::test_code_examples -v

# Run with detailed output
pytest tests/test_html2md_server.py -vv -s

# Run only fast tests
pytest tests/test_html2md_server.py -m "not slow"
```

## Test Coverage

### Core Features Tested

- ✅ Basic HTML to Markdown conversion
- ✅ Async I/O operations with aiofiles
- ✅ CSS selector content extraction
- ✅ Element filtering with ignore selectors
- ✅ Complex nested HTML structures
- ✅ Code block language detection
- ✅ Table conversion (simple and complex)
- ✅ List conversion (ordered, unordered, nested)
- ✅ Special characters and HTML entities
- ✅ Unicode support
- ✅ YAML frontmatter generation
- ✅ Heading level offset adjustment
- ✅ Parallel processing with asyncio
- ✅ Configuration file loading (YAML/TOML)
- ✅ CLI argument parsing
- ✅ API mode for programmatic access
- ✅ HTTrack integration (when available)
- ✅ URL conversion from lists

### Performance Testing

- Parallel conversion of multiple files
- Large file handling
- Memory usage monitoring
- Conversion speed benchmarks

## Writing New Tests

### Adding Test Pages

1. Create HTML file in `tests/html2md_server/test_pages/`
2. Register in `server.py`:
   ```python
   TEST_PAGES = {
       'your-test': {
           'title': 'Your Test Title',
           'description': 'What this tests'
       }
   }
   ```
3. Add corresponding test case

### Test Case Structure

```python
class TestYourFeature:
    async def test_your_feature(self, test_server, temp_output_dir):
        """Test description."""
        from tools.html2md.api import HTML2MDConverter

        converter = HTML2MDConverter(
            outermost_selector="main",
            ignore_selectors=["nav", "footer"],
            add_frontmatter=True
        )

        # Perform async conversion
        results = await converter.convert_directory(
            f"{test_server.base_url}/page",
            temp_output_dir
        )

        # Assert expected results
        assert len(results) > 0
```

## Continuous Integration

### GitHub Actions Integration

```yaml
# .github/workflows/test.yml
- name: Run HTML2MD Tests
  run: |
    cd tests/html2md_server
    ./run_tests.sh
```

### Local Development

```bash
# Watch mode for development
pytest-watch tests/test_html2md_server.py

# Run with debugging
pytest tests/test_html2md_server.py --pdb
```

## Troubleshooting

### Common Issues

**Server won't start**

- Check if port 8080 is already in use
- Ensure Flask dependencies are installed
- Check Python version (3.9+ required)

**Tests fail with connection errors**

- Ensure server is running
- Check firewall settings
- Verify localhost resolution

**Coverage report issues**

- Install pytest-cov: `pip install pytest-cov`
- Ensure tools.html2md module is in Python path
- For async tests, use pytest-asyncio: `pip install pytest-asyncio`

## Future Enhancements

1. **Additional Test Pages**
   - SVG content handling
   - MathML equations
   - Microdata and structured data
   - Progressive web app features
   - WebAssembly integration tests
   - Shadow DOM content extraction

2. **Test Automation**
   - Visual regression testing
   - Performance benchmarking
   - Memory leak detection
   - Cross-platform testing

3. **Enhanced Reporting**
   - HTML test reports with screenshots
   - Conversion diff visualization
   - Performance metrics dashboard

## Contributing

To contribute to the test suite:

1. Identify untested scenarios
2. Create representative HTML test pages
3. Write comprehensive test cases
4. Document the test purpose
5. Submit PR with test results

The test suite aims to cover all real-world HTML conversion scenarios to ensure
robust and reliable Markdown output.
